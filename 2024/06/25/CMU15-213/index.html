

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fabulous">
  <meta name="keywords" content="">
  
    <meta name="description" content="本篇主要记录在学习课程CMU15-213(version:sp23)以及配套教材CS:APP中的总结、梳理、拓展以及个人感想。Lab部分会记录解题思路在另外部分。 Overview 对应CS:APP第一章  让我们从详细理解一段代码的生命周期开始深入了解计算机在这一过程中完成了哪些操作。 1234567#include &lt;stdio.h&gt;int main() &#123;    pri">
<meta property="og:type" content="article">
<meta property="og:title" content="CMU15-213">
<meta property="og:url" content="https://fabulous1496.github.io/2024/06/25/CMU15-213/index.html">
<meta property="og:site_name" content="Fabulous&#39;s little world">
<meta property="og:description" content="本篇主要记录在学习课程CMU15-213(version:sp23)以及配套教材CS:APP中的总结、梳理、拓展以及个人感想。Lab部分会记录解题思路在另外部分。 Overview 对应CS:APP第一章  让我们从详细理解一段代码的生命周期开始深入了解计算机在这一过程中完成了哪些操作。 1234567#include &lt;stdio.h&gt;int main() &#123;    pri">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabulous1496.github.io/Pictures/CMU15-213/cover.jpg">
<meta property="article:published_time" content="2024-06-25T13:11:49.000Z">
<meta property="article:modified_time" content="2024-07-08T16:33:14.151Z">
<meta property="article:author" content="Fabulous">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://fabulous1496.github.io/Pictures/CMU15-213/cover.jpg">
  
  
  
  <title>CMU15-213 - Fabulous&#39;s little world</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"fabulous1496.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"CjZvdepCB7OjY30a6oge7W6x-gzGzoHsz","app_key":"ErsGn5pjObFn129dKnLC8esg","server_url":"https://cjzvdepc.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fabulous&#39;s little world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Pictures/CMU15-213/cover.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CMU15-213"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-25 21:11" pubdate>
          2024年6月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.5k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          80 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">CMU15-213</h1>
            
            
              <div class="markdown-body">
                
                <p>本篇主要记录在学习课程CMU15-213(version:sp23)以及配套教材CS:APP中的总结、梳理、拓展以及个人感想。<br>Lab部分会记录解题思路在另外部分。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><blockquote>
<p>对应CS:APP第一章</p>
</blockquote>
<p>让我们从详细理解一段代码的生命周期开始深入了解计算机在这一过程中完成了哪些操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>hello程序的生命周期是从一个高级的C语言程序开始的，但是在机器执行时需要将这些语句转化为一系列的低级<strong>机器语言</strong>指令。然后这些指令按照一种称为<strong>可执行目标程序</strong>的格式打包，并以二进制磁盘文件的形式存放起来。</p>
<p>通过一条指令 <em>gcc -o hello hello.c</em> ，我们便可以将程序编译为可执行文件。具体而言，一般需要经历以下过程。</p>
<p><img src="/Pictures/CMU15-213/%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" lazyload alt="编译系统"></p>
<ul>
<li><strong>预处理阶段</strong>。预处理器（cpp）根据 # 开头的命令修改原始的C程序。在这里，include语句告诉预处理器将stdio.h文件中从内容插入程序文本中。经过这一步，我们实现了从 <em>hello.c</em>到<em>hello.i</em>的变化。</li>
<li><strong>编译阶段</strong>。编译器（ccl）将文本文件 <em>hello.i</em> 翻译成 <em>hello.s</em> ，即翻译为汇编语言程序。</li>
<li><strong>汇编阶段</strong>。汇编器（as）将 <em>hello.s</em> 翻译为机器语言指令并打包为<strong>可重定位目标程序</strong>的格式，并保存在二进制文件 <em>hello.o</em> 中。</li>
<li><strong>链接阶段</strong>。在hello程序中调用了printf函数，该函数保存在<em>printf.o</em>文件中，链接过程就是将这些文件以某种方式进行合并。合并完成后我们得到<strong>可执行目标文件</strong> <em>hello</em>。</li>
</ul>
<p>在得到可执行目标文件后，我们可以将其输入到shell（命令行解释器）中。</p>
<p>为了更深入的理解运行程序时计算机内部发生了什么，我们需要了解一个典型系统的硬件知识。</p>
<img src="/Pictures/CMU15-213/System model.png" srcset="/img/loading.gif" lazyload>

<ol>
<li><p>总线</p>
<p>总线携带信息字节并负责在各个部件之间进行传递。通常总线被设计为定长的字节块，也就是字（word）。32位指代4字节，而64位指代8字节。</p>
</li>
<li><p>I&#x2F;O设备</p>
<p>输入输出设备时系统与外部世界进行联系的通道。常见的I&#x2F;O设备包括键鼠、显示器、磁盘等。每个设备都通过一个<strong>控制器</strong>或<strong>适配器</strong>与I&#x2F;O总线相连。</p>
<p>控制器与适配器之间的区别在于封装方式。控制器通常是I&#x2F;O设备本身或者系统的主板上的芯片组，而适配器时插在主板上的卡。</p>
</li>
<li><p>主存</p>
<p>主存是一个临时存储设备，用于存放程序和程序处理的数据。主存由一组<strong>动态随机存取存储器（DRAM）</strong>芯片组成。从逻辑上来说，存储器是一个线性的字节数组，每一个字节都有其唯一的地址（数组索引）。</p>
</li>
<li><p>处理器</p>
<p>处理器（CPU）是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC），在任何时刻，PC都指向主存中某条机器指令。</p>
<p>指令集架构决定指令执行模型。</p>
</li>
</ol>
<p>在运行代码的过程中，数据需要在内存、处理器、总线上来回搬运。因此要提高运行速度，就需要是这些复制搬运操作加快。我们可以通过在处理器和较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如cache）来加速这个过程，于是便产生了一个<strong>存储器层次结构</strong>。</p>
<p><img src="/Pictures/CMU15-213/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload alt="存储器层次结构"></p>
<p>为了防止硬件被失控的应用程序滥用以及提供一个简单一致的机制来控制复杂低级的硬件，我们使用操作系统来提供这些服务。操作系统提供了几个基本的抽象概念来实现基本功能。</p>
<p><img src="/Pictures/CMU15-213/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" srcset="/img/loading.gif" lazyload alt="操作系统"></p>
<ul>
<li><p>进程</p>
<p>进程是操作系统对正在运行的程序的一种抽象。一个系统可以同时运行多个进程。在系统中，一个CPU通过在进程之间切换来实现交错执行的机制，称为<em>上下文切换</em>，也是CPU能进行并发执行的原因。在这里，上下文是一个抽象的概念，指操作系统保持跟踪进程运行所需的所有状态信息。上下文切换时，操作系统会保存当前状态的上下文，恢复新进程的上下文。新进程会从上次中断的地方开始。</p>
</li>
<li><p>线程</p>
<p>一个进程可以由多个称为线程的执行单元组成。</p>
</li>
<li><p>虚拟内存</p>
<p>虚拟内存为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存是一致的，称为虚拟地址空间。</p>
<p>对于所有进程而言，代码是从统一固定位置开始，紧接着的是和C全局变量相对应的数据位置。</p>
<p>涉及的一些名词和概念：</p>
<ul>
<li><strong>运行时堆</strong>：代码和数据在进程一开始时确定大小，调用函数时堆可以在运行时动态的扩展和收缩。</li>
<li><strong>共享库</strong>：用于存放C标准库和数学库这样的共享的代码和数据。</li>
<li><strong>用户栈</strong>：用于实现函数的调用。调用函数时会导致栈增长，函数返回时栈收缩。</li>
<li><strong>内核虚拟内存</strong>：应用程序调用内核执行操作。</li>
</ul>
</li>
</ul>
<p><img src="/Pictures/CMU15-213/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png" srcset="/img/loading.gif" lazyload alt="虚拟地址空间"></p>
<p><strong>Amdahl定律</strong>：在对系统某个部分进行加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。假设执行某应用程序所需要的时间为$T_{old}$，某部分与执行时间总体的比例为$\alpha$，该部分提升性能比例为$k$，则有：<br>$$<br>T_{new}&#x3D;(1-\alpha)T_{old}+(\alpha T_{old})&#x2F;k&#x3D;T_{old}[(1-\alpha)+\alpha&#x2F;k]<br>$$<br>$$<br>S&#x3D;T_{old}&#x2F;T_{new}&#x3D; \frac{1}{(1-\alpha)+\alpha&#x2F;k}<br>$$</p>
<p>$$<br>k\to\infty,\quad S_\infty&#x3D;\frac{1}{1-\alpha}<br>$$<br>最后，我们来了解并发与并行。一般来说，我们重点从三个抽象级层次来理解。</p>
<ol>
<li>线程级并发。简单来说，就是利用一个处理器同时处理多个线程。这其中需要用到<strong>超线程技术</strong>，具体来说就是CPU内部的寄存器和PC有多个备份，用于储存不同的线程上下文，而共用一份其它的硬件。</li>
<li>指令级并行。利用一个处理器同时执行多条指令。</li>
<li>单指令、多数据并行。利用特殊的硬件允许一条指令产生多个可以并行执行的操作，简称SIMD并行。</li>
</ol>
<h1 id="Representing-and-Manipulating-Information"><a href="#Representing-and-Manipulating-Information" class="headerlink" title="Representing and Manipulating Information"></a>Representing and Manipulating Information</h1><blockquote>
<p>对应原书CS:APP第二章</p>
</blockquote>
<h2 id="Representing-information-as-bits"><a href="#Representing-information-as-bits" class="headerlink" title="Representing information as bits"></a>Representing information as bits</h2><p>在现代计算机系统中，我们通常用位（bits）：0&#x2F;1来表示数据。</p>
<table>
<thead>
<tr>
<th>C Data Type</th>
<th>Typical 32-bit</th>
<th>Typical 64-bit</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>pointer</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h2 id="Boolean-Algebra"><a href="#Boolean-Algebra" class="headerlink" title="Boolean Algebra"></a>Boolean Algebra</h2><p>布尔代数：我们用0代表false，1代表true</p>
<p>布尔运算：定义四种基本布尔运算。对于 Bit Vectors，采取逐位计算的方式。</p>
<ol>
<li>AND:  A&amp;B &#x3D; 1 when A &#x3D; 1 and B &#x3D; 1</li>
<li>OR:  A | B &#x3D; 1 when A &#x3D; 1 or B &#x3D; 1 or both</li>
<li>NOT:  ~A &#x3D; 1 when A &#x3D; 0</li>
<li>XOR:  A^B &#x3D; 1 when A !&#x3D; B</li>
</ol>
<p>对于Bit Vectors 的运算，我们可以采用下面这种表示方式：若一个Bit Vector 定义为A，我们从左至右从0开始给每一位编号，然后将其中为1的位的序号组成一个集合，代表这个向量。</p>
<p>例如：$A&#x3D;01101001 \quad \rightarrow \quad {0,3,5,6},B&#x3D;01010101 \quad \rightarrow \quad {0,2,4,6}$</p>
<p>这样表示后，我们可以将布尔代数转化为集合的运算：</p>
<ul>
<li>&amp;  交集（intersection）：A&amp;B&#x3D;{0,6}</li>
<li>|  并集（union）：A|B&#x3D;{0,2,3,4,5,6}</li>
<li>^  相异的元素（Symmetric difference）：A^B&#x3D;{2,3,4,5}</li>
<li>~  补集（Complement）：~A&#x3D;{1,2,4,7}</li>
</ul>
<div class="note note-info">
            <p>C语言的Shift Operations：</p><p>x&lt;&lt;y:将一个整数x的二进制形式向左移动y位，右侧用0填补，在数学意义上会导致值乘2的y次方。</p><p>例：5(0000 0101)&lt;&lt;2 &#x3D; 5*2^2&#x3D;20(0001 0100)</p><p>x&gt;&gt;y:分为算术右移和逻辑右移。</p><p>算术右移会保留符号位（最高位），即右移操作不改变数字的正负。而逻辑右移不考虑符号位，直接将左侧用0填充。</p>
          </div>



<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><p>一些关于转换编码的名词：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>$B$</td>
<td>数据类型</td>
<td>Binary，二进制数</td>
</tr>
<tr>
<td>$T$</td>
<td>数据类型</td>
<td>Two’s Complement，补码</td>
</tr>
<tr>
<td>$U$</td>
<td>数据类型</td>
<td>Unsigned，无符号数</td>
</tr>
<tr>
<td>$\omega$</td>
<td>常数</td>
<td>数据表示的位数</td>
</tr>
<tr>
<td>$X2Y_\omega$</td>
<td>函数</td>
<td>从$X$的数据类型转换为$Y$</td>
</tr>
<tr>
<td>$TMin_\omega$ &#x2F; $TMax_\omega$</td>
<td>常数</td>
<td>最小&#x2F;最大补码值</td>
</tr>
<tr>
<td>$UMax_\omega$</td>
<td>常数</td>
<td>最大无符号数</td>
</tr>
<tr>
<td>$+^{t}_{\omega}$  &#x2F;  $+^u_\omega$</td>
<td>运算操作</td>
<td>补码  &#x2F;  无符号数加法</td>
</tr>
<tr>
<td>$*^t_\omega$  &#x2F;  $*^u_\omega$</td>
<td>运算操作</td>
<td>补码  &#x2F;  无符号数乘法</td>
</tr>
<tr>
<td>$-^t_\omega$  &#x2F;  $-^u_\omega$</td>
<td>运算操作</td>
<td>补码  &#x2F;  无符号数取反</td>
</tr>
</tbody></table>
<p>无符号数的编码定义：<br>$$<br>B2U_\omega(x)&#x3D;\sum_{i&#x3D;0}^{\omega-1}x_i 2^i<br>$$<br>补码编码定义：即最高有效位的权值为负数。<br>$$<br>B2T_\omega(x)&#x3D;-x_{\omega-1}2^{\omega-1}+\sum_{i&#x3D;1}^{\omega-2}x_i 2^i<br>$$<br>可以把反码理解为最高有效位的权值为$2^{\omega-1}-1$。故有补码&#x3D;反码+1.</p>
<p>无符号数加法(包含溢出情况)：<br>$$<br>x+y&#x3D;\begin{cases}x+y \ ,\ x+y\le2^\omega \\ x+y-2^\omega \ , \ x+y\ge2^\omega \end{cases}<br>$$<br>补码加法（包含正溢出和负溢出）：<br>$$<br>x+y&#x3D;\begin{cases}x+y-2^\omega \ , \ x+y\ge2^{\omega-1}  \\ x+y \\ x+y+2^\omega \ , \ x+y&lt;-2^{\omega-1} \end{cases}<br>$$</p>
<h2 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h2><p>浮点数的编码表示：利用小数点后的第$i$位来表示权值为$2^{-i}$的位。</p>
<p>例如，浮点数$0.111_2&#x3D;1\times2^{-1}+1\times2^{-2}+1\times2^{-3}&#x3D;0.5+0.25+0.125&#x3D;0.875$</p>
<p><strong>IEEE浮点表示</strong>：IEEE浮点标准用$V&#x3D;(-1)^s\times M\times 2^E$的形式来表示一个数。</p>
<ul>
<li>符号（sign）：s决定这个数的正负属性</li>
<li>尾数（significand）M是一个二进制小数，范围是$1\sim 2-\varepsilon$，或者是$0 \sim 1-\varepsilon$</li>
<li>阶码（exponent）E的作用是对浮点数进行加权，这个权重是2的E次幂（可能是负次幂）</li>
<li>一个单独的符号位编码s</li>
<li>k位的阶码字段 $exp&#x3D;e_{k-1}…e_1e_0$编码阶码E</li>
<li>n位的小数字段$frac&#x3D;f_{n-1}…f_1f_0$编码位数M</li>
</ul>
<p>单精度与双精度浮点数的存储：</p>
<p><img src="/Pictures/CMU15-213/float.png" srcset="/img/loading.gif" lazyload alt="float"></p>
<p>根据不同的exp的取值，被编码的值可以分为三种不同的情况：</p>
<ol>
<li><p>规格化的，此时 $exp \ne 0 且\ne 255$，此时$E&#x3D;e-Bias$，其中$Bias&#x3D;2^{k-1}-1$，单精度为127，双精度为1023. 指数的范围为单精度$-126 \sim 127 $，双精度为$-1022 \sim 1023$。</p>
<p>小数字段frac被解释为$0.f_{n-1}…f_1f_0$，尾数定义为$M&#x3D;1+f$。这种方式也被称为隐含的以1开头的表示。</p>
</li>
<li><p>非规格化，此时$exp&#x3D;0$，在这种情况下，阶码值是$E&#x3D;1-Bias$，尾数的值为$M&#x3D;f$，也就是小数字段的值，不包含隐含的开头的1.</p>
</li>
<li><p>特殊值，当阶码全为1即$exp&#x3D;255$时，小数域全为0时，得到的值表示无穷。当小数域的结果非0时，结果值被称为NaN。</p>
</li>
</ol>
<p>浮点数的<strong>舍入（Rounding）</strong>：</p>
<p>浮点数的舍入有多种方式，下面举例说明四种常见的舍入方式：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>1.40</th>
<th>1.60</th>
<th>1.50</th>
<th>2.50</th>
<th>-1.50</th>
</tr>
</thead>
<tbody><tr>
<td>向偶数舍入</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>-2</td>
</tr>
<tr>
<td>向零舍入</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>-1</td>
</tr>
<tr>
<td>向上舍入</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>向下舍入</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>-2</td>
</tr>
</tbody></table>
<p>向偶数舍入是计算机默认的舍入方式，其原理是找到一个最接近的整数进行舍入，在出现两个结果的中间数时（1.5,2.5等）使舍入后的数最低有效位为偶数。</p>
<p>向偶数舍入的优势是：在计算平均值是，向上舍入或向下舍入会导致整体的平均值偏大或偏小，而向偶数舍入在大多数情况下避免了这种现实偏差，即有50%的概率向上舍入，同时有50%的概率向下舍入。</p>
<p>浮点数的运算：</p>
<p>我们将浮点值的计算定义为$x+y&#x3D;Round(x+y)$，只需要计算到一个可以得到正确舍入结果的答案即可。</p>
<p>浮点加法不具有结合性。例如$3.14+1e10-1e10&#x3D;0$，这是因为计算前两项时由于舍入的原因值3.14会丢失。而计算$3.14+(1e10-1e10)&#x3D;3.14$。</p>
<p>同时，这也导致了浮点乘法不具备分配性。</p>
<h1 id="Machine-Level-Representation-of-Programs"><a href="#Machine-Level-Representation-of-Programs" class="headerlink" title="Machine-Level Representation of Programs"></a>Machine-Level Representation of Programs</h1><blockquote>
<p>对应原书第三章内容</p>
</blockquote>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>首先了解几个常见名词：</p>
<ul>
<li><p>Architecture（架构）：指指令集架构（ISA），是处理器设计的一部分，编写汇编&#x2F;机器代码的人需要了解这部分。</p>
<p>例子：指令集规范，寄存器</p>
</li>
<li><p>Microarchitecture（微架构）：指架构的具体实现方式。</p>
<p>例子：缓存大小和核心频率。</p>
</li>
<li><p>Code Forms（代码形式）：分为Machine Code（机器代码）和Assembly Code（汇编代码）。前者主要指处理器执行的字节级程序，后者主要指机器代码的文本表示形式。</p>
</li>
<li><p>ISAs（指令集架构）：x86-64，ARM，RISC V等。</p>
</li>
</ul>
<p>下面通过一个例子来了解编程语言、汇编语言和机器码之间的转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">mult2</span><span class="hljs-params">(<span class="hljs-type">long</span>, <span class="hljs-type">long</span>)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">multstore</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> *dest)</span> &#123;<br>    <span class="hljs-type">long</span> t = mult2(x, y);<br>    *dest = t;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将这段代码转换成汇编代码<code>gcc -Og -S mstore.c</code>，得到的结果如下（省略以“.”开头的行代表的伪指令）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">multstore:<br>	pushq  %rbx<br>	movq   %rdx, %rbx<br>	call   mult2<br>	movq   %rax, (%rbx)<br>	popq   %rbx<br>	ret<br></code></pre></td></tr></table></figure>

<p>而再次将这段代码转为机器码<code>gcc -Og -c mstore.c</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">53</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> d3 e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">03</span> <span class="hljs-number">5</span>b c3<br></code></pre></td></tr></table></figure>

<p>利用反汇编器进行反汇编后<code>objdump -d mstore.o</code>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000000000</span> &lt;multstore&gt;:<br>	<span class="hljs-attribute">0</span>:  <span class="hljs-number">53</span>                 push    %rbx<br>	<span class="hljs-attribute">1</span>:  <span class="hljs-number">48</span> <span class="hljs-number">89</span> d3           mov     %rdx,%rbx<br>	<span class="hljs-attribute">4</span>:  e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>     callq   <span class="hljs-number">9</span> &lt;multstore+<span class="hljs-number">0</span>x9&gt;<br>	<span class="hljs-attribute">9</span>:  <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">03</span>           mov     %rax,(%rbx)<br>	<span class="hljs-attribute">c</span>:  <span class="hljs-number">5</span>b                 pop     %rbx<br>	<span class="hljs-attribute">d</span>:  c3                 retq<br></code></pre></td></tr></table></figure>

<p>因此，机器执行的程序只是一个字节序列。利用反汇编器，我们可以得到原始的汇编代码。从这个例子中，我们可以总结出这样的规律：</p>
<ul>
<li>x86-64的指令长度从1到15个字节不等，常用的指令以及操作数较少的指令所需的字节数烧，而那些不太常用的或操作数较多的指令所需字节数较多。</li>
<li>字节可以唯一地解码成机器指令。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。他不需要访问该程序的源代码或汇编代码。</li>
</ul>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel用术语“word”表示16为数据类型，因此称32位数为“double words”，64位数为“quad words”</p>
<p>C语言类型数据在x86-64中的大小，在64为机器中，指针长8字节：</p>
<table>
<thead>
<tr>
<th>C声明</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>字节</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>字</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>双字</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>char*</td>
<td>四字</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>单精度</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>双精度</td>
<td>l</td>
<td>8</td>
</tr>
</tbody></table>
<p>一个x86-64的中央处理单元（CPU）包含一个一组16个储存64位值的<em>通用目的寄存器</em>。这些寄存器用来存储正数数据和指针。他们的名字都以%r开头。</p>
<p><img src="/Pictures/CMU15-213/registers.png" srcset="/img/loading.gif" lazyload alt="registers"></p>
<h2 id="汇编基本指令"><a href="#汇编基本指令" class="headerlink" title="汇编基本指令"></a>汇编基本指令</h2><h3 id="基本操作数"><a href="#基本操作数" class="headerlink" title="基本操作数"></a>基本操作数</h3><p>各种操作数可以分为三种类型：</p>
<ol>
<li><p>立即数，用于表示常数值，书写方式为”$”后跟一个用C表示法表示的整数。</p>
</li>
<li><p>寄存器，表示某个寄存器的内容，16个寄存器的低位1、2、4、8字节中的一个作为操作数，对应8、16、32、64位。我们用$r_a$表示寄存器a，用$R[r_a]$来表示它的值。这表示将寄存器集合看成一个数组。</p>
<p><strong>寄存器有一个特点：任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0.</strong></p>
</li>
<li><p>内存引用，根据据计算出来的有效地址访问某个内存位置。因为将内存看成一个很打动字节数组，我们用符号$M_b[Addr]$表述对存储在内存中从地址Addr开始的b个字节的引用。</p>
<p>一种最常见的寻址模式：$Imm(r_b,r_i,s)$，包括四个组成部分，一个立即数偏移$Imm$,一个基址寄存器$r_b$，一个变址寄存器$r_i$，一个比例因子$s&#x3D;1，2，4，8$，有效地址的计算为$Imm+R[r_b]+R[r_i]\cdot s$</p>
</li>
</ol>
<p><img src="/Pictures/CMU15-213/addrSearch.png" srcset="/img/loading.gif" lazyload alt="addrSearch"></p>
<h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>数据传送指令——MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。</p>
<p>MOV类指令由四条指令组成：movb,movw,movl,movq。这些指令操作的数据大小分别为1、2、4、8字节。源操作数指定的值是一个立即数，储存在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者是一个内存地址。</p>
<p>源和目的的组合有五种：I2R，I2M，R2R，R2M，M2R。</p>
<blockquote>
<p>I–Imm    R–register    M–Memory</p>
</blockquote>
<p>常规的<code>movq</code>指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号拓展得到64位的值，放到目的位置。而<code>movabsq</code>指令能够以任意64位立即数值位源操作数，并且只能以<strong>寄存器</strong>作为目的。</p>
<p>基于MOV类衍生出MOVZ类和MOVS类指令，用于将较小的源值复制到较大的目的时使用。所有这些指令的<strong>目的都为寄存器</strong>。MOVZ使用零扩展，而MOVS使用符号扩展。MOVS类中的cltq只用于将%eax符号扩展到%rax，效果与movslq %eax，%rax完全一致，不过编码更紧凑。</p>
<p><strong>关于直接寻址和间接寻址</strong>：在学习时，笔者对直接寻址和间接寻址的概念比较模糊，在这里对于这两个概念进行总结，以一个例子入手。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">section .data<br>    value: dq 10          ; 定义一个数据段变量，初始值为 10<br><br>section .text<br>    global _start<br><br>_start:<br>    mov value, %rbx       ; 将变量 value 的地址移动到 rbx 寄存器中<br>    mov (%rbx), %rcx      ; 将 rbx 寄存器指向的内存地址处的值（10）移动到 rcx 寄存器中<br>    add $2, %rcx          ; 将立即数 2 加到 rcx 寄存器的当前值上（现在 rcx 中的值是 12）<br>    mov %rcx, (%rbx)      ; 将 rcx 寄存器中的值（12）移动回 rbx 指向的内存地址处（更新 value 的值为 12）<br></code></pre></td></tr></table></figure>

<p>这里有两个关键易混淆的点要注意：</p>
<ol>
<li>在指令中，<code>value</code>并不是一个立即数，而是看做内存中的一个地址（假设为0x1000），在内存0x1000这个地址储存了整数10。因此，第一步操作<code>mov value, %rbx</code>代表将地址<code>0x1000</code>存入<code>rbx</code>寄存器中而不是将数值<code>10</code>存入<code>rbx</code>。</li>
<li>第二步很好地说明了间接取址和直接取址之间的区别：<code>(%rbx)</code>代表的是内存中的一个地址，具体为<code>rbx</code>内储存的地址<code>0x1000</code>。而<code>%rcx</code>代表寄存器中的<code>rcx</code>。这步操作将 <code>rbx</code> 寄存器指向的内存地址 <code>0x1000</code> 处的值（即 <code>value</code> 的值，这里是 10）移动到 <code>rcx</code> 寄存器中。这里可以把内存和寄存器看为两个不同的数组M和R，<code>rbx</code>存放的是<code>0x1000=R[r_b]</code>，<code>rcx</code>存放的是数<code>10=R[r_c]</code>,<code>(%rbx)=M[R[r_b]]=M[0x1000]</code>存放的是value的值。</li>
</ol>
<h3 id="压栈-弹栈"><a href="#压栈-弹栈" class="headerlink" title="压栈&#x2F;弹栈"></a>压栈&#x2F;弹栈</h3><p>栈是满足先入后出的顺序结构，一般用push代表压栈，pop代表出栈。栈指针<code>%rsp</code>保存着栈顶元素的地址。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>pushq    S</td>
<td>R[%rsp]-8 $\to$ R[%rsp];S $\to$ M[R[%rsp]]</td>
<td>将四字压入栈</td>
</tr>
<tr>
<td>popq    D</td>
<td>M[R[%rsp]] $\to$ D;R[%rsp]+8 $\to$ R[%rsp]</td>
<td>将四字弹出栈</td>
</tr>
</tbody></table>
<p>指令 <code>pushq %rbp</code>的行为等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">subq  $8,%rsp<br>movq  %rbp,(%rsp)<br></code></pre></td></tr></table></figure>

<p>同理，指令<code>popq  %rax</code>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq  (%rsp),%rax<br>addq  $8,%rsp<br></code></pre></td></tr></table></figure>



<h3 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h3><p>操作被分为四类：加载有效地址，一元操作，二元操作和移位。</p>
<p><img src="/Pictures/CMU15-213/ops.png" srcset="/img/loading.gif" lazyload alt="ops"></p>
<ol>
<li><p>加载有效地址（load effective address）指令实际上是<code>movq</code>指令的变形。在形式上是从内存读取数据到寄存器，但实际上根本没有引用内存。第一个操作数看上去是一个内存引用，但实际上是将有效地址写入到目的操作数。</p>
<p>例如：<code>leaq 7(%rdx, %rdx, 4), %rax</code>。我们假设rdx的值为$x$，那么rax的值为$5x+7$.</p>
<p>所以，利用这条指令，我们可以实现简单的算术运算。</p>
</li>
<li><p>一元操作：具体涉及到四种操作，分别是加一、减一、取负、取补</p>
</li>
<li><p>二元操作：前面的操作数称为源S，第二个操作数称为目的D，结果被存储在目的D里面。</p>
</li>
<li><p>移位操作：注意逻辑右移和算数右移的区别，逻辑左移和算术左移没有区别。</p>
</li>
</ol>
<p>除开上面讨论的几种操作之外，还有几类特殊的算术操作。两个64为有符号数或无符号数相乘需要128位来表示。在x86-64指令集中，对128位（16bytes）的操作提供一些有限的支持。这些特殊操作就是对16字进行操作。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>imulq&#x2F;mulq    S</td>
<td>R[%rdx];S*R[%rax] –&gt; R[%rax]</td>
<td>有符号&#x2F;无符号全乘法</td>
</tr>
<tr>
<td>clto    S</td>
<td></td>
<td>转换为8字</td>
</tr>
<tr>
<td>idivq&#x2F;divq    S</td>
<td></td>
<td>有符号&#x2F;无符号除法</td>
</tr>
</tbody></table>
<p>在执行两个64位数的128位乘积是，要求一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出，然后将乘积存放在%rdx（高64位）和%rax（低64位）中。</p>
<p>下面从C语言和汇编代码的角度进一步剖析这条指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inttypes.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> __int128 <span class="hljs-type">unit128_t</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">store_uprod</span><span class="hljs-params">(<span class="hljs-type">uint128_t</span> *dest, <span class="hljs-type">uint64_t</span> x, <span class="hljs-type">uint64_t</span> y)</span> &#123;<br>    *dest = x * (<span class="hljs-type">uint128_t</span>)y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>gcc生成的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;dest in %rdi, x in %rsi, y in %rdx<br>store_uprod:<br>	movq	%rsi,%rax    ;Copy x to multiplicand<br>	mulq	%rdx         ;Multiply by y<br>	movq	%rax,(%rdi)  ;Store lower 8 bytes at dest<br>	movq	%rdx,8(%rdi) ;Store upper 8 bytes at dest+8<br>	ret<br></code></pre></td></tr></table></figure>

<p>对于大多数64位除法应用来说，除数也常常是一个64位的值，这个值应该存放在%rax中，%rdx的位应该全设置为0或者符号位。后面这个操作可以用指令<code>cqto</code>来完成，它不需要操作数，会隐含读出%rax的符号位并复制到%rdx的所有位。</p>
<p>从C语言和汇编代码的角度进行进一步解析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">remdiv</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y, <span class="hljs-type">long</span> *qp, <span class="hljs-type">long</span> *rp)</span> &#123;<br>    <span class="hljs-type">long</span> q = x/y;<br>    <span class="hljs-type">long</span> r = x%y;<br>    *qp = q;<br>    *rp = r;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>gcc生成的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x in %rdi, y in %rsi, qp in %rdx, rp in %rcx<br>remdiv:<br>	movq	%rdx,%r8		;Copy qp<br>	movq	%rdi,%rax		;move x to lower 8 bytes of dividend<br>	cqto					;Sign extend to upper 8 bytes<br>	idivq	%rsi			;Divide by y<br>	movq	%rax,(%r8)		;Store quotient at qp<br>	movq	%rdx,(%rcx)		;Store remainder at rp<br>	ret<br></code></pre></td></tr></table></figure>



<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU还维护了一组单个位的条件码寄存器，描述了最近的算数或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。最常用的条件码包括：</p>
<ul>
<li>CF：进位标志。最近的操作数是最高位产生了进位，可以检测无符号操作的溢出。</li>
<li>ZF：零标志。最近的操作得到的结果为0.</li>
<li>SF：符号标志。最近的操作得到的结果为负数。</li>
<li>OF：溢出标志。最近的操作导致一个补码溢出。</li>
</ul>
<p>leaq操作不改变任何条件码，除此之外其余指令都有可能改变条件码。对于<strong>逻辑操作</strong>，进位和溢出标志会被设为0.</p>
<p>我们也可以使用一些指令来设置条件码：</p>
<p><img src="/Pictures/CMU15-213/Condition.png" srcset="/img/loading.gif" lazyload alt="Condition code"></p>
<p>其中，CMP指令根据两个操作数之差来设置条件码，TEST根据两个操作数的AND运算。典型用法是将两个操作数设置为一样的来检测正负，或者将一个设置为掩码来测试特定位。</p>
<p>条件码一般有三种使用方式：</p>
<ol>
<li>根据条件码的某些组合，将一个字节设置为0或者1</li>
<li>条件跳转到程序的某个部分</li>
<li>有条件地传输数据</li>
</ol>
<p>实现条件码设置字节我们使用SET指令，在指令中，<strong>“设置”</strong>代表赋值为1。</p>
<p><img src="/Pictures/CMU15-213/Set.png" srcset="/img/loading.gif" lazyload alt="Set"></p>
<p>分析各函数的效果，我们发现有符号数的比较主要涉及<code>SF,OF,ZF</code>，而无符号数的比较涉及<code>CF,ZF</code>。</p>
<p>下面是一个例子，实现比较两个数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;a in %rdi, b in %rsi<br>comp:<br>	cmpq	%rsi,%rdi		;Compare a:b<br>	setl	%al				;Set low-order byte of %eax to 0 or 1<br>	movzbl	%al, %eax		;Clear rest of %eax (and rest of %rax)<br>	ret<br></code></pre></td></tr></table></figure>

<p>此处主要注意movzbl指令（1 to 4），该指令不仅会把%eax的高3个字节清零，还会把整个寄存器%rax的高四个字节都清零。</p>
<p>我们假设此处<code>a&lt;b</code>，那么<code>cmpq</code>会将<code>SF、CF</code>置为1，而<code>ZF、OF</code>为0 。接下来<code>setl</code>指令会将<code>SF^OF</code>的值赋给<code>D</code>，因此在这里<code>%al</code>将被设置为1，最终函数返回结果为1.</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>jump指令会导致执行切换到程序中一个全新的位置。在程序中，一般会有一个Label来指明跳转的位置。</p>
<p>跳转指令可以是<strong>直接跳转</strong>，即跳转目标是作为指令的一部分来编码的；也可以是<strong>间接跳转</strong>，即跳转目标是从寄存器或内存位置中读出的。直接跳转直接使用一个标号作为跳转目标，而间接跳转的写法是*<em>＋操作数指示符</em>。</p>
<p>例如指令<code>jmp *%rax</code>用寄存器%rax中的值作为跳转目标，而指令<code>jmp *(%rax)</code>用%rax中的值读出地址，从内存中读出跳转目标。</p>
<p><img src="/Pictures/CMU15-213/jump.png" srcset="/img/loading.gif" lazyload alt="jump"></p>
<p>跳转指令的编码：在汇编代码中，跳转目标用符号标号书写。跳转指令有几种不同的编码，但常用的都是PC相对的。也就是会将目标指令的地址紧跟在跳转指令后面的那条指令的地址间的差值作为编码，可以是1、2、4字节。第二种方法是绝对地址编码，用四个 字节直接指定目标。</p>
<p>下面看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">movq	%rdi,%rax<br>jmp		.L2<br> .L3:<br> 	sarq	%rax<br> .L2:<br> 	testq	%rax,%rax<br> 	jg		.L3<br> 	rep,ret<br></code></pre></td></tr></table></figure>

<p>对应的反汇编版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0:	48 89 f8					mov		%rdi,%rax<br>3:	eb 03						jmp		8 &lt;loop+0x8&gt;<br>5:	48 d1 f8					sar		%rax<br>8:	48 85 c0					test	%rax,%rax<br>b:	7f f8						jg		5 &lt;loop+0x5&gt;<br>d:	f3 c3						repz retq<br></code></pre></td></tr></table></figure>

<p>这里可以从反汇编器产生的注释明确读出.L2的跳转目标指明为0x8（test行），.L3为0x5 （sar行）。而观察字节编码，发现.L2的字节编码为03，而.L3的字节编码为f8 。这里就是利用PC相对的编码方式，目标指令（test行）为0x8，下一条指令（sar行）地址为0x5，故差值0x3为.L2编码。同理，目标指令（sar行）为0x5，下一条指令（rep行）为0xd，插指0xf8（十进制-8）为.L3编码。</p>
<p>因此，三个地址之间我们可以做到知二求一。<strong>目标地址&#x3D;标志编码+下一行地址</strong></p>
<p>利用跳转指令，我们可以实现条件分支和循环结构。</p>
<h4 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h4><p>下面是一个用<strong>控制的条件转移</strong>思路写出的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> lt_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-type">long</span> ge_cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-title function_">absdiff_se</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span> &#123;<br>    <span class="hljs-type">long</span> result;<br>    <span class="hljs-keyword">if</span>(x&lt;y) &#123;<br>        lt_cnt++;<br>        result = y - x;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        ge_cnt++;<br>        result = x - y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>与上述代码等价的goto代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">gotodiff_se</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span> &#123;<br>    <span class="hljs-type">long</span> result;<br>    <span class="hljs-keyword">if</span>(x &gt;= y) &#123;<br>        <span class="hljs-keyword">goto</span> x_ge_y;<br>    &#125;<br>    lt_cnt++;<br>    result = y - x;<br>    <span class="hljs-keyword">return</span> result;<br>x_ge_y:<br>    ge_cnt++;<br>    result = x - y;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将goto代码转换为汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x in %rdi, y in %rsi<br>absdiff_se:<br>	cmpq	%rsi, %rdi					;Compare x:y<br>	jge		.L2							;if &gt;= goto x_ge_y<br>	addq	$1, lt_cnt(%rip)			;lt_cnt++<br>	movq	%rsi, %rax<br>	subq	%rdi, %rax					;result = y - x<br>	ret<br>  .L2:<br>  	addq	$1, ge_cnt(%rip)<br>  	movq	%rdi, %rax<br>  	subq	%rsi, %rax<br>  	ret<br></code></pre></td></tr></table></figure>

<p>当然，有时为了提高效率，我们可以使用<strong>数据的条件转移</strong>，即先计算出所有分支产生的结果，再判断需要传送哪个结果。例如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-title function_">cmovdiff</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> y)</span><br>&#123;<br>    <span class="hljs-type">long</span> rval = y-x;<br>    <span class="hljs-type">long</span> eval = x-y;<br>    <span class="hljs-type">long</span> ntest = (x &gt;= y);<br>    <span class="hljs-keyword">if</span>(ntest)<br>        rval = eval;<br>    <span class="hljs-keyword">return</span> rval;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>产生的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;x in %rdi, y in %rsi<br>absdiff:<br>	movq	%rsi, %rax			<br>	subq	%rdi, %rax			;rval = y-x<br>	movq	%rdi, %rdx<br>	sunq	%rsi, %rdx			;eval = x-y<br>	cmpq	%rsi, %rdi			;Compare x:y<br>	comvge	%rdx, %rax			;if &gt;=,rval = eval<br>	ret							;return tval<br></code></pre></td></tr></table></figure>

<p>里面涉及到一类条件传送指令：<code>comv</code>，条件传送指令再条件满足时把源值S复制到目的R。</p>
<p><img src="/Pictures/CMU15-213/comv.png" srcset="/img/loading.gif" lazyload alt="cmov"></p>
<p>当然，需要注意的是，不是所有条件表达式都可用条件传送来编译。最重要的是，当语句会产生除返回值的副作用时，可能会导致一些错误。</p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ol>
<li><p><strong>do-while循环</strong></p>
<p>该语句的通用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span><br>    body-statement<br>    <span class="hljs-title function_">while</span><span class="hljs-params">(test-expr)</span><br></code></pre></td></tr></table></figure>

<p>这种通用形式可以被翻译为如下所示的条件和goto语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">loop:<br>	body-statement<br>    t = test-expr;<br>	<span class="hljs-keyword">if</span>(t)<br>        <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure>

<p>假设我们有一个实现阶乘的函数，下面是一个等价的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;n in %rdi<br>fact_do:<br>	movl	$1, %eax			;Set result = 1<br>  .L2:							;Loop:<br>  	imulq	%rdi, %rax			;	result *= n<br>  	subq 	$1, %rdi			;	n = n-1<br>  	cmpq	$1, %rdi			;Compare n:1<br>  	jg		.L2					;if &gt;, goto Loop<br>  	rep; ret					;Return<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>while循环</strong></p>
<p>通用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(test-expr)<br>    body-statement<br></code></pre></td></tr></table></figure>

<p>与上一个循环的不同之处在于，我们需要在第一次运行代码之前进行条件判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">	<span class="hljs-keyword">goto</span> test;<br>loop:<br>	body-statement<br>test:<br>	t = test-expr;<br>	<span class="hljs-keyword">if</span>(t)<br>        <span class="hljs-keyword">goto</span> loop;<br></code></pre></td></tr></table></figure>

<p>另一种方式是将while转换为do-while：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">t = test-expr;<br><span class="hljs-keyword">if</span>(!t)<br>    <span class="hljs-keyword">goto</span> done;<br><span class="hljs-keyword">do</span><br>    body-statement<br>    <span class="hljs-title function_">while</span><span class="hljs-params">(test-expr)</span>;<br>done:<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>for循环</strong></p>
<p>for循环的通用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(init-expr; test-expr; update-expr)<br>    body-statement<br></code></pre></td></tr></table></figure>

<p>可以利用while循环改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">init-expr;<br><span class="hljs-keyword">while</span>(test-expr) &#123;<br>    body-statement<br>    update-expr;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>switch语句</strong></p>
<p>在这里，我们引入一个新的数据结构跳转表，跳转表是一个数组，每个元素是一个指向代码位置的指针，：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">switch_eg_impl</span><span class="hljs-params">(<span class="hljs-type">long</span> x, <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> *dest)</span> <br>&#123;<br>    <span class="hljs-comment">// Table of code pointers</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span> *jt[<span class="hljs-number">3</span>]=&#123;&amp;&amp;loc_A, &amp;&amp;loc_B, &amp;&amp;loc_C&#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> index = n - <span class="hljs-number">100</span>;<br>    <span class="hljs-type">long</span> val;<br>    <span class="hljs-keyword">if</span>(index&gt;<span class="hljs-number">6</span>)<br>        <span class="hljs-keyword">goto</span> loc_def;<br>    <span class="hljs-keyword">goto</span> *jt[index];<br>    <br>    loc_A:<br>    	val = x*<span class="hljs-number">13</span>;<br>    	<span class="hljs-keyword">goto</span> done;<br>    loc_B:<br>    	x = x + <span class="hljs-number">10</span><br>    ......<br>    done:<br>    	*dest = val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在C语言中，switch语句依靠跳转表实现。而在汇编代码中，跳转表以如下声明来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section	.rodata<br>.align 8<br> .L4:<br> 	.quad	.L3				;Case 1<br> 	.quad	.L8				;Case 2<br> 	.quad 	.L5				;Case 3<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程提供了一种代码的封装方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后可以在程序中不同的地方调用这个函数。不同编程语言中，对过程的定义多种多样：函数（function），方法（method），子例程（subroutine），处理函数（handler）等，但是它们有一些共有的特性。</p>
<p>假设过程P调用过程Q，Q执行后返回到P。这些动作包括下面一个或多个机制：</p>
<ul>
<li><em>传递控制</em>，在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。</li>
<li><em>传递数据</em>，P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li>
<li><em>分配和释放内存</em>，在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<p>接下来，我们先描述控制，再描述传递，最后描述内存管理。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>在x86-64中，运行时栈向低地址方向增长。当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个过程称为过程的<strong>栈帧</strong>。下图给出了一个运行时栈的通用结构：</p>
<p><img src="/Pictures/CMU15-213/stack.png" srcset="/img/loading.gif" lazyload alt="stack"></p>
<p>当前正在执行的过程的帧总是在栈顶。当过程P调用Q时，会将返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。我们把这个返回地址当作P栈帧的一部分。Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。借助寄存器，过程P最多可以传递6参数。也就是说，当参数不多于6个时，可以不创建栈帧。</p>
<h3 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h3><p>将控制从函数P转到函数Q只需要简单把PC设置为Q的代码的起始位置。不过Q返回时，处理器必须记录好它需要继续P的执行的代码位置。在x86-64机器中，这个信息是用指令<code>call</code>来记录的。该指令会将地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A被称为返回地址，是紧跟在call指令后面那一条指令的地址。ret会将A弹出并把PC设置为A。</p>
<p>利用下图我们可以更加直观的感受到call函数的运行：</p>
<p><img src="/Pictures/CMU15-213/call.png" srcset="/img/loading.gif" lazyload alt="call"></p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。</p>
<p>x86-64中，可以通过寄存器传递最多6个整型参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如下表所示：</p>
<table>
<thead>
<tr>
<th>操作数大小（位）&#x2F;参数数量</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>%rdi</td>
<td>%rsi</td>
<td>%rdx</td>
<td>%rcx</td>
<td>%r8</td>
<td>%r9</td>
</tr>
<tr>
<td>32</td>
<td>%edi</td>
<td>%esi</td>
<td>%edx</td>
<td>%ecx</td>
<td>%r8d</td>
<td>%r9d</td>
</tr>
<tr>
<td>16</td>
<td>%di</td>
<td>%si</td>
<td>%dx</td>
<td>%cx</td>
<td>%r8w</td>
<td>%r9w</td>
</tr>
<tr>
<td>8</td>
<td>%dil</td>
<td>%sil</td>
<td>%dl</td>
<td>%cl</td>
<td>%r8b</td>
<td>%r9b</td>
</tr>
</tbody></table>
<p>如果一个函数有大于6个的参数，那么超出6个的部分需要通过栈来传递。</p>
<p>下面看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">proc</span><span class="hljs-params">(<span class="hljs-type">long</span> a1, <span class="hljs-type">long</span> *a1p, <span class="hljs-type">int</span> a2, <span class="hljs-type">int</span> *a2p, <span class="hljs-type">short</span> a3, <span class="hljs-type">short</span> *a3P, <span class="hljs-type">char</span> a4, <span class="hljs-type">char</span> *a4p)</span><br>&#123;<br>    *a1p += a1;<br>    *a2p += a2;<br>    *a3p += a3;<br>    *a4p += a4;<br>        <br>&#125;<br></code></pre></td></tr></table></figure>

<p>生成的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;a1 in %rdi, a1p in %rsi, a2 in %edx, a2p in %rcx, a3 in %r8w, a3p in %r9, a4 at %rsp+8, a4p at %rsp+16<br>proc:<br>	movq	16(%rsp), %rax<br>	addq	%rdi, (%rsi)<br>	addl	%edx, (%rcx)<br>	addw	%r8w, (%r9)<br>	movl 	8(%rsp), %edx<br>	addb	%dl, (%rax)<br>	ret<br></code></pre></td></tr></table></figure>

<p>寄存器组是唯一被所有过程共享的资源，虽然在给定时刻只有一个过程是活动的，但是仍然需要保证一个过程在调用时不会覆盖另一个过程保存的数据。</p>
<p>按照惯例，寄存器%rbx,%rbp以及%r12-%r15被划分为被调用者保存寄存器，举个例子就是在P调用Q时，Q必须保存这些寄存器的值不能改变。</p>
<p>同样的，由于栈的特点，我们可以很容易理解递归函数的调用过程。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>对于数据类型T和整型常数N，我们声明一个数组如下：T  A[ N ]；</p>
<p>这个声明有两个效果：首先在内存中分配一个L*N字节的连续区域，这里的L是指数据类型T的大小。其次引入了一个标识符A，作为指向数组开头的指针。</p>
<p>假设我们访问一个int数组，E的地址存放在%rdx中，i存放在%rcx中，那么访问<code>E[i]</code>的指令为：<code>movl  (%rdx,%rcx,4), %eax</code>。</p>
<p>C语言允许对指针进行运算，其效果为将指针指向下一个数据类型大小的地址。例如<code>*(E+1)</code>的效果等同于<code>E[1]</code>。下表给出了一些常见的指针运算：</p>
<p><img src="/Pictures/CMU15-213/ptr.png" srcset="/img/loading.gif" lazyload alt="ptr"></p>
<p>这里需要注意，两个指针相减计算的是指针之间的距离，以元素为单位。</p>
<p>同样的，嵌套数组在储存中也是线性储存的，即按照<strong>行优先</strong>的顺序排列。</p>
<h2 id="结构体和联合"><a href="#结构体和联合" class="headerlink" title="结构体和联合"></a>结构体和联合</h2><p>结构体的所有组成成分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器指示每个字段的字节偏移，以这些偏移作为内存引用指令中的唯一，从而产生对结构元素的引用。</p>
<p>下图的例子可以很好的说明：</p>
<p><img src="/Pictures/CMU15-213/struct_eg.png" srcset="/img/loading.gif" lazyload alt="struct_eg"></p>
<p>而共用体用于将不同类型的数据存储在同一块内存空间中。所有成员共享相同的内存位置。</p>
<p><strong>内存分配</strong>：共用体的大小是其最大成员的大小，所有成员重叠存储在同一内存空间中。</p>
<p><strong>访问</strong>：同一时间只能访问一个成员，修改一个成员会影响其他成员的值。可以简单理解为Union可以作为代表它内部的任何一个成员的单个元素，而结构体是包含内部成员的集合。</p>
<p>考虑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">S3</span> &#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">U3</span> &#123;</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> i[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">double</span> v;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可以同时访问S3中的c，i和v，因为在结构体中这三者是同时存在的的。而U3可以作为其中之一出现，三者不是同时存在的。</p>
<p>字段偏移量如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>c</th>
<th>i</th>
<th>v</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>S3</td>
<td>0</td>
<td>4</td>
<td>16</td>
<td>24</td>
</tr>
<tr>
<td>U3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>8</td>
</tr>
</tbody></table>
<p>这里涉及到数据对齐的原则，即某种类型对象的地址必须是某个值K（通常是2，4，8）的倍数。因此在这里尽管<code>char c</code>只占用了一个字节，但是i的起始地址仍然是4.同时i结束后v起始地址应该是12，但为了double的数据对齐，起始地址必须为8的倍数，因此起始地址为16.</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是C语言的一个核心特色，他们以一种统一的方式，对不同的数据结构中的元素产生引用。下面重点介绍一些指针和它们映射到机器代码的关键原则：</p>
<ol>
<li><p>每个指针都对应一种数据类型。</p>
<p>特殊指针 <code>void *</code>类型代表通用指针，可以通过强制类型转换或者赋值操作那样的隐式强制类型转换将其转换成一个有类型的指针。注意<strong>指针类型不是机器代码中的一部分，它们是C语言提供的一种抽象，帮助理解避免寻址错误</strong>。</p>
</li>
<li><p>每个指针都有一个值。这个值是某个指定类型对象的地址。</p>
</li>
<li><p>指针用‘&amp;’运算符创建。&amp;运算符的机器代码实现常常利用指令<code>leaq</code>。</p>
</li>
<li><p>‘*’操作符用于简介引用指针。其结果是一个值，类型与指针类型一致。</p>
</li>
<li><p>将指针从一种类型强制转换为另一种类型，不改变指针的值。</p>
</li>
<li><p>指针可以指向函数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> *p)</span>;<br><span class="hljs-type">int</span> (*fp)(<span class="hljs-type">int</span> ,<span class="hljs-type">int</span> *);<br>*fp = fun;<br><span class="hljs-type">int</span> y = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> result = fp(<span class="hljs-number">3</span>, &amp;y);<br></code></pre></td></tr></table></figure>

<p>函数指针的值是该函数机器代码表示中第一条指令的值。</p>
</li>
</ol>
<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p>AVX浮点体系结构允许数据存储在16个YMM寄存器中，命名为%ymm0 $\sim$ %ymm15，每个YMM寄存器都是256位（32字节）。低16字节命名为%xmm0 $\sim$ %xmm15.</p>
<p>相应的，浮点操作也包括传送、转换、运算、比较等，下面直接给出对应的指令表：</p>
<p><img src="/Pictures/CMU15-213/vmov.png" srcset="/img/loading.gif" lazyload alt="vmov"></p>
<p><img src="/Pictures/CMU15-213/trans.png" srcset="/img/loading.gif" lazyload alt="trans"></p>
<p><img src="/Pictures/CMU15-213/fops.png" srcset="/img/loading.gif" lazyload></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CMU15-213/" class="category-chain-item">CMU15-213</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CMU15-213</div>
      <div>https://fabulous1496.github.io/2024/06/25/CMU15-213/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fabulous</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年6月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/01/DataLab/" title="DataLab">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">DataLab</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/20/GNN%E2%80%94%E2%80%94%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="GNN——图神经网络">
                        <span class="hidden-mobile">GNN——图神经网络</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"CjZvdepCB7OjY30a6oge7W6x-gzGzoHsz","appKey":"ErsGn5pjObFn129dKnLC8esg","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
