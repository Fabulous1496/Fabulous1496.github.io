

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Fabulous">
  <meta name="keywords" content="">
  
    <meta name="description" content="Testing在工程中，为自己编写UnitTest时刻检测代码的正确性是十分重要且必要的。 假设我们现在有这样一个类，它实现对一个int类型的数组进行排序： 1234567891011121314151617181920public class Sort &#123;    public static void swap(int[] arr, int i, int j) &#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Fabulous の CS~61b 奇妙⭐冒险记">
<meta property="og:url" content="https://fabulous1496.github.io/2024/02/29/CS61B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Fabulous&#39;s little world">
<meta property="og:description" content="Testing在工程中，为自己编写UnitTest时刻检测代码的正确性是十分重要且必要的。 假设我们现在有这样一个类，它实现对一个int类型的数组进行排序： 1234567891011121314151617181920public class Sort &#123;    public static void swap(int[] arr, int i, int j) &#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabulous1496.github.io/Pictures/CS61b/02/cover.jpg">
<meta property="article:published_time" content="2024-02-29T11:11:27.000Z">
<meta property="article:modified_time" content="2024-03-27T14:13:21.195Z">
<meta property="article:author" content="Fabulous">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://fabulous1496.github.io/Pictures/CS61b/02/cover.jpg">
  
  
  
  <title>Fabulous の CS~61b 奇妙⭐冒险记 - Fabulous&#39;s little world</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"fabulous1496.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"CjZvdepCB7OjY30a6oge7W6x-gzGzoHsz","app_key":"ErsGn5pjObFn129dKnLC8esg","server_url":"https://cjzvdepc.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fabulous&#39;s little world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Pictures/CS61b/02/cover.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Fabulous の CS~61b 奇妙⭐冒险记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-29 19:11" pubdate>
          2024年2月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          136 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Fabulous の CS~61b 奇妙⭐冒险记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>在工程中，为自己编写UnitTest时刻检测代码的正确性是十分重要且必要的。</p>
<p>假设我们现在有这样一个类，它实现对一个int类型的数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = tmp;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; x.length - <span class="hljs-number">1</span>; i++) &#123;<br>            minIndex = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; x.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (x[j] &lt; x[minIndex]) &#123;<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            swap(x, i, minIndex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以编写一个SortTest类，来测试排序是否满足要求，假设我们要求将数组升序排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testsort</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span>[] input = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>&#125;;<br>        <span class="hljs-type">int</span>[] expected = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>        Sort.sort(input);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.length; i +=<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!(input[i] == expected[i]))<br>            &#123;<br>                System.out.println(<span class="hljs-string">&quot;Mismatch in position &quot;</span> + i + <span class="hljs-string">&quot;, expected: &quot;</span> + expected[i] + <span class="hljs-string">&quot;, but got: &quot;</span> + input[i] + <span class="hljs-string">&quot;.&quot;</span>);<br>                isSuccess = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(isSuccess)<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Success!No case failed!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        testsort();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一种近乎最原始的测试方式，但是可以直接有效的测试我们代码的可行性。</p>
<h2 id="JUnit-Testing"><a href="#JUnit-Testing" class="headerlink" title="JUnit Testing"></a>JUnit Testing</h2><p>org.junit 库提供了许多有用的方法和有用的功能来简化测试的编写。例如，我们可以将上面的简单临时测试替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSort</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] input = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>&#125;;<br>    <span class="hljs-type">int</span>[] expected = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;;<br>    Sort.sort(input);<br>    org.junit.Assert.assertArrayEquals(expected, input);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此方法测试 expected 和 actual 是否相等，如果不相等，则终止程序并显示详细错误消息。</p>
<h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><h2 id="The-Mystery-of-the-Walrus"><a href="#The-Mystery-of-the-Walrus" class="headerlink" title="The Mystery of the Walrus"></a>The Mystery of the Walrus</h2><p>现在有两段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Walrus</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Walrus</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">8.3</span>);<br>Walrus b;<br>b = a;<br>b.weight = <span class="hljs-number">5</span>;<br>System.out.println(a);<br>System.out.println(b);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y;<br>y = x;<br>x = <span class="hljs-number">2</span>;<br>System.out.println(<span class="hljs-string">&quot;x is: &quot;</span> + x);<br>System.out.println(<span class="hljs-string">&quot;y is: &quot;</span> + y);<br></code></pre></td></tr></table></figure>

<p>对于第一段代码，我们输出结果能够发现a与b指向了同一个对象，而在第二段代码中，x和y却是不同的数值。</p>
<p>在java中，声明变量（基础类型的8种）并不会进行初始化。</p>
<p>这就意味着，如果有这样一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> x;<br></code></pre></td></tr></table></figure>
<p>如果不对x进行赋值，我们将无法使用变量x，即未完成实例化。</p>
<p>除开基础类型以外，其他的所有内容（包括数组）都不是原始类型，而是reference type。</p>
<p>当我们声明任何引用类型时，Java都会分配一个64bits的空间，无论对象是什么类型。</p>
<p>关键字new会将创建出的对象实例的<strong>地址</strong>传给左侧声明的对象。</p>
<p>赋值符号 “&#x3D;”  表示将右侧变量的bits传给左侧对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dog</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">Dog</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure>

<p>第一行表示声明一个Dog变量a，创建一个“10”的Dog实例并将其的地址传递给a，所以第二行表示将此实例的地址同样的拷贝传递给b，因此a和b实际上指向同一实例。</p>
<p>也就是说，对于基础类型，Java采用值传递的方式；而对于引用类型（reference type），Java采用引用传递的类型，这导致传递之后两个变量实际上指向同一个地址。</p>
<p>如上所述，储存数组的变量也是一种引用类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] x;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>x = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>第一行声明了一个int类型的数组x，但是并没有进行初始化，也就是说x内部为null。第二行则是创建了一个实例并将其绑定到数组x上，但是当第三行执行完毕后，我们将永远丢失数组{1, 2, 3}。</p>
<h2 id="First-taste-of-IntLists"><a href="#First-taste-of-IntLists" class="headerlink" title="First taste of IntLists"></a>First taste of IntLists</h2><p>我们可以尝试构建一个自己的int链表，包括获取大小、获取数据方法的实现（我最喜欢recursion了，我爱说实话）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> first;<br>    <span class="hljs-keyword">public</span> Intlist rest;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntList</span><span class="hljs-params">(<span class="hljs-type">int</span> f, IntList r)</span> &#123;<br>        first = f;<br>        rest = r;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(rest == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">this</span>.rest.size()<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> first;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rest.get(i-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="The-SLList"><a href="#The-SLList" class="headerlink" title="The SLList"></a>The SLList</h2><p>在上面的链表实现中，用户可以直接看到内部的数据结构，这种 <em>naked</em> 的效果显然不是我们所期待的。</p>
<p>因此，我们将链表再次包装一层，避免裸露的数据结构，形成嵌套结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">public</span> IntNode next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IntNode</span><span class="hljs-params">(<span class="hljs-type">int</span> i, IntNode n)</span> &#123;<br>        item = i;<br>        next = n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后，我们创建一个名为 <em>SLList</em> 的单独类，用户将与之交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLList</span> &#123;<br>    <span class="hljs-keyword">public</span> IntNode first;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来是一些基础方法的实现，包括：addFirst, getFirst, addLast, size</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLList</span> &#123;<br>    <span class="hljs-keyword">private</span> IntNode first;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, first);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> first.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">IntNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">while</span>(p.next != <span class="hljs-literal">null</span>) &#123;<br>            p = p.next;<br>        &#125;<br>        p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">IntNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> first;<br>        <span class="hljs-keyword">if</span>(p.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        p = p.next;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + p.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>直观比较两个数据结构的区别：</p>
<p><img src="/Pictures/CS61b/02/IntList_vs_SLList.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>本质上，SLList 类充当列表用户和裸递归数据结构之间的中间人。正如上面在 IntList 版本中所建议的，IntList 用户可能拥有指向 IntList 中间的变量。进一步，我们还可以将属性改为<em>private</em>。</p>
<h3 id="Nested-Classes"><a href="#Nested-Classes" class="headerlink" title="Nested Classes"></a>Nested Classes</h3><p>对于SLList而言，IntNode是其中的嵌套类。</p>
<p>这种嵌套关系我们一般称之为 <em>“has-a”</em> 关系。</p>
<p>如果嵌套类不需要使用SLList的任何实例方法或变量，则可以声明为 <em>static</em> ，这意味着静态类中的方法无法访问封闭类的任何成员，节省内存。</p>
<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>对 <em>size()</em> 方法进行分析，我们不难发现时间复杂度为 <em>O(n)</em> 。对于较大的列表来说，时间较长，所以我们考虑直接添加一个变量来跟踪当前链表的长度，这样时间复杂度变为了 *O(1)*。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    ...<br>    size = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    ...<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    ...<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，我们发现初始创建空链表时，对其进行addLast方法会导致错误，这是因为 first 是 null ，因此尝试访问下面 while (p.next !&#x3D; null) 中的 p.next 会导致空指针异常。</p>
<p>我们考虑加入不变的头节点(head)，在此课程中称为 <em>Sentinel Node</em> 。</p>
<p>重构之后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLList</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <span class="hljs-keyword">private</span> IntNode sentinel;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        sentinel = IntNode(<span class="hljs-number">10</span>, <span class="hljs-literal">null</span>);<br>        sentinel.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>        size = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SLList</span><span class="hljs-params">()</span> &#123;<br>        sentinel = IntNode(<span class="hljs-number">10</span>, <span class="hljs-literal">null</span>);<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        sentinel.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, first);<br>        size += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sentinel.next.item;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">IntNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> sentinel.next;<br>        <span class="hljs-keyword">while</span>(p.next != <span class="hljs-literal">null</span>) &#123;<br>            p = p.next;<br>        &#125;<br>        p.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntNode</span>(x, <span class="hljs-literal">null</span>);<br>        size += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="The-DLList"><a href="#The-DLList" class="headerlink" title="The DLList"></a>The DLList</h2><p>对于SLList来说，向前搜索是十分困难的，当我们想获取最后一个节点时，不可避免的需要遍历整个链表。</p>
<p>因此我们考虑构造双向链表，每个节点都保存了前一个节点和后一个节点的信息。</p>
<p>主要有两种实现方式：循环链表(单个sentinel)和双向链表(双sentinel)。</p>
<p><img src="/Pictures/CS61b/02/dllist_circular_sentinel_size_2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/Pictures/CS61b/02/dllist_double_sentinel_size_2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLList</span> &#123;<br>    <span class="hljs-keyword">private</span> IntNode sentinel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>        <span class="hljs-keyword">public</span> IntNode prev;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> item;<br>        <span class="hljs-keyword">public</span> IntNode next;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="First-try-of-Generic-Model"><a href="#First-try-of-Generic-Model" class="headerlink" title="First try of Generic Model"></a>First try of Generic Model</h3><p>在Java中，我们可以通过泛型编程来实现对不同数据类型数据的存储。</p>
<p>基本语法是：在类声明中的类名之后，在尖括号内使用任意占位符 &lt;&gt; ,然后在任何使用任意类型的地方都使用该占位符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DLList</span>&lt;TypeName&gt; &#123;<br>    <span class="hljs-keyword">private</span> IntNode sentinel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntNode</span> &#123;<br>        <span class="hljs-keyword">public</span> IntNode prev;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> item;<br>        <span class="hljs-keyword">public</span> IntNode next;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在实例化时，需要指明类型名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DLList&lt;String&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DLList</span>&lt;&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br>d2.addLast(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>创建数组有三种有效的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];    <span class="hljs-comment">//x = &#123;0, 0, 0&#125;</span><br><span class="hljs-type">int</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] z = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>Java中内置了一些与数组操作相关的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> x.lenght;    <span class="hljs-comment">//获取长度</span><br><span class="hljs-type">int</span>[] b = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>System.arraycopy(b,<span class="hljs-number">0</span>,x,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);    <br><span class="hljs-comment">/**复制数组，参数为源数组、开始坐标、目标数组、开始坐标、个数</span><br><span class="hljs-comment">等同于Python中的 x[3:5]=b[0:2]*/</span><br></code></pre></td></tr></table></figure>

<p>在Java中，多维数组中的每个子数组可以有不同的长度。这种情况下，这些数组被称为不规则多维数组。Java中的多维数组实际上是数组的数组，因此每个子数组可以独立地具有不同的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">pascalsTriangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>][];<br>pascalsTriangle[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>&#125;;<br>pascalsTriangle[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>pascalsTriangle[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;;<br>pascalsTriangle[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="The-AList"><a href="#The-AList" class="headerlink" title="The AList"></a>The AList</h2><p>对于链表来说，获取第i个节点元素需要从前向后遍历i次，这说明时间复杂度为 <em>O(n)</em> 。而在现代计算机上访问数组的第i个元素所需要的时间是恒定的，即 <em>O(1)</em> 。</p>
<p>A naive solution:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AList</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-comment">/** Creates an empty list. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AList</span><span class="hljs-params">()</span> &#123;<br>        items = (T []) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Inserts X into the back of the list. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        items[size] = x;<br>        size = size + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the item from the back of the list. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> items[size - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">/** Gets the ith item in the list (0 is the front). */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> items[i];<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns the number of items in the list. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/** Deletes item from back of the list and</span><br><span class="hljs-comment">      * returns deleted item. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> getLast();<br>        size = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>对于这个方案，我们不难发现：数组的大小在一开始便固定下来了，这会导致我们在使用的过程中总会有空间浪费或空间不足的情况出现。</p>
<p>考虑性能，我们采用算法计算出最优化的数组大小并动态更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    T[] tmp = (T []) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    System.arraycopy(items,<span class="hljs-number">0</span>,tmp,<span class="hljs-number">0</span>,size);<br>    items = tmp;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBack</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == items.length) &#123;<br>        resize(size * RFACTOR);<br>    &#125;<br>    items[size] = x;<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Inheritance-Implements"><a href="#Inheritance-Implements" class="headerlink" title="Inheritance &amp; Implements"></a>Inheritance &amp; Implements</h1><h2 id="Hypernyms-Hyponyms-and-Interfaces-Inheritance"><a href="#Hypernyms-Hyponyms-and-Interfaces-Inheritance" class="headerlink" title="Hypernyms, Hyponyms, and Interfaces Inheritance"></a>Hypernyms, Hyponyms, and Interfaces Inheritance</h2><p>具有 <em>“is-a”</em> 关系的词语之间互相为上位词与下位词。</p>
<p>例如：狗是贵宾犬、雪橇犬、哈士奇等的上位词。相反，贵宾犬、雪橇犬和哈士奇是狗的下位词。</p>
<p>换种说法，贵宾犬、雪橇犬、哈士奇都是狗的子类，而狗是贵宾犬、雪橇犬、哈士奇等的超类。</p>
<p>在Java中，为了表达这种层次结构，我们需要做两件事：</p>
<ol>
<li>定义上位词的类型</li>
<li>指定下位词</li>
</ol>
<p>我们定义出来的上位词类型便是所谓的接口（interface），它本质上只定义类所需要的功能，并不提供具体的实现方法，这一点可以看作C++中的抽象基类。</p>
<p>如果我们为之前创建的列表定义一个接口，那么应该是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List61B</span>&lt;Item&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(Item x)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(Item y)</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Item x, <span class="hljs-type">int</span> position)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，我们把AList和SLList指定为List61B的下位词，需要用到 <em>implement</em> 关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AList</span>&lt;Item&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List61B</span>&lt;Item&gt; &#123;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SLList</span>&lt;Item&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List61B</span>&lt;Item&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于在接口中，我们仅仅声明了类中所包含的一些方法，并没有给出具体的实现过程，因此在子类中，我们需要对函数进行重写覆盖。在子类中实现所需的函数时，在方法签名的顶部包含 <em>@Override</em> 标记很有用。实际上，即使不包含标签，我们依旧在进行重写（Overriding）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(Item x)</span> &#123;<br>    insert(x, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和C++中一样，在Java中，接口类型的对象可以接受子类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List61B&lt;String&gt; someList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SLList</span>&lt;String&gt;();<br>    someList.addFirst(<span class="hljs-string">&quot;elk&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当它运行时，SLList 被创建，它的地址存储在 someList 变量中。然后字符串“elk”被插入到addFirst引用的SLList中。</p>
<p>在interface中，我们仅仅定义了方法头但并没有具体的实现。如果我们需要在接口中进行函数的实现并继承到子类中，我们可以在函数前加上 <em>default</em> 关键字。如果子类中没有重写，则会调用default方法，如果子类进行了重写，则会使用子类中的重写方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size(); i += <span class="hljs-number">1</span>) &#123;<br>        System.out.print(get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Interface-Inheritance-vs-Implementation-Inheritance"><a href="#Interface-Inheritance-vs-Implementation-Inheritance" class="headerlink" title="Interface Inheritance vs Implementation Inheritance"></a>Interface Inheritance vs Implementation Inheritance</h3><ul>
<li>Interface Inheritance（接口继承）：<br>接口继承是通过接口来定义的，一个接口可以扩展另一个接口。<br>通过接口继承，子接口可以继承父接口的抽象方法，但不继承任何具体的实现。<br>子接口可以定义新的抽象方法，或者通过默认方法提供方法的默认实现。<br>类实现一个接口时，必须提供接口中所有抽象方法的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mammal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Mammal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is eating&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog is sleeping&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Implementation Inheritance（实现继承）：<br>实现继承是通过类来定义的，一个类可以继承另一个类。<br>通过实现继承，子类继承了父类的所有属性和方法，包括具体的实现。<br>子类可以通过方法重写（override）来改变或扩展父类的方法的行为。<br>Java中一个类只能继承一个父类，即使是多重继承也只能通过接口实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing shape&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Externs-Casting-Higher-Order-Functions"><a href="#Externs-Casting-Higher-Order-Functions" class="headerlink" title="Externs, Casting, Higher Order Functions"></a>Externs, Casting, Higher Order Functions</h2><p>我们使用 <em>implements</em> 关键字定义了类与接口之间的关系，对于类和类之间、接口与接口之间的继承关系，我们可以使用关键字 <em>extends</em> 进行定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RotatingSLList</span>&lt;Item&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SLList</span>&lt;Item&gt;&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VengefulSLList</span>&lt;Item&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SLList</span>&lt;Item&gt;&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>子类可以继承父类中的所有实例和静态变量，所有方法以及所有嵌套类。注意构造函数不是继承的，私有成员不能被子类直接访问。</p>
<p>虽然构造函数不是继承的，但 Java 要求所有构造函数都必须从调用其超类的构造函数之一开始。如果我们选择不这样做，Java 将自动为我们调用超类的<strong>无参构造函数</strong>。请注意，如果super class中的构造函数是有参的，那么要求在子类中显式地调用此构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">VengefulSLList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    deletedItems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SLList</span>&lt;Item&gt;();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java 中的每个类都是 <strong>Object</strong> 类或 <strong>extends Object</strong> 类的后代。即使类中没有显式 extends 的类仍然隐式扩展 <strong>Object</strong> 类。</p>
<p>Object 类提供了每个 Object 都应该能够执行的操作，例如 <em>.equals(Object obj)</em> 、 <em>.hashCode()</em> 和 <em>toString()</em> 。</p>
<p>有界类型参数：<br>在Java中，有界类型参数（bounded type parameters）是指在泛型类或泛型方法中对类型参数进行限制，使其必须是某种特定类型或其子类型。有界类型参数通常用于提高泛型的灵活性和安全性。</p>
<p>有界类型参数有两种：上界限定（upper bounded）和下界限定（lower bounded）。</p>
<ol>
<li>上界限定：使用 extends 关键字指定类型参数必须是某个类或接口的子类。例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-info">
            <p>在这个例子中，类型参数 T 必须是 Number 类或其子类，这意味着可以传递 Integer、Double、Float 等类型作为 T。</p>
          </div>

<ol start="2">
<li>下界限定：使用 super 关键字指定类型参数必须是某个类的超类。例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T <span class="hljs-built_in">super</span> Integer&gt; &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<div class="note note-info">
            <p>在这个例子中，类型参数 T 必须是 Number 类或其子类，这意味着可以传递 Integer、Double、Float 等类型作为 T。</p>
          </div>


<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>在编写代码的过程中，维持代码的 <em>Abstraction Barriers</em> 是非常重要的！（梦回61a）</p>
<p>在Java中，我们可以轻易地实现抽象障碍，比如使用private关键字。</p>
<p>但是继承可以破坏这种封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span> &#123;<br>    barkMany(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">barkMany</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">1</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;bark&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">barkMany</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;As a dog, I say: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">1</span>) &#123;<br>        bark();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>前两个是基类，第三个则是子类中的部分。</p>
<p>调用子类中的函数，程序陷入无限循环。对 bark() 的调用将调用 barkMany(1) ，后者又调用 bark() ，无限次地重复该过程。</p>
<h3 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h3><p>Java 有一种特殊的语法，您可以告诉编译器特定的表达式具有特定的编译时类型。</p>
<p>例如，我们有下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dosomething</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">func</span><span class="hljs-params">(A a)</span> &#123;<span class="hljs-keyword">return</span> a;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dosometing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Haha!&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">donothing</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> B <span class="hljs-title function_">func</span><span class="hljs-params">(B b)</span> &#123;<span class="hljs-keyword">return</span> b;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">testb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">testa</span> <span class="hljs-operator">=</span> testb;<br>        testa.dosomething();<br>        testa.donothing();<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> testa.func(testb);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据动态方法选择，调用dosomething时，检测到子类重写了这个方法，所以testa执行B中的dosomething函数。但编译器根据对象的静态类型确定某些内容是否有效，A中并没有donothing，所以会出错。</p>
<p>同样，func返回的是A类对象，不能用子类B类的对象直接接收。</p>
<p>我们使用casting解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (B) testa.func(testb);<br></code></pre></td></tr></table></figure>

<h3 id="Higher-Order-Function"><a href="#Higher-Order-Function" class="headerlink" title="Higher Order Function"></a>Higher Order Function</h3><p>Python中，高阶函数是一个很有用的工具</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tenX</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>*x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_twice</span>(<span class="hljs-params">f,x</span>):<br>    <span class="hljs-keyword">return</span> f(f(x))<br></code></pre></td></tr></table></figure>

<p>在Java中，我们可以利用接口继承实现高阶函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IntUnaryFunction</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">tenX</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IntUnaryFunction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> * x;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_twice</span><span class="hljs-params">(IntUnaryFunction f, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-keyword">return</span> f.apply(f.apply(x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有点类似于函数对象（谓词，伪函数）的实现。</p>
<h2 id="Subtype-Polymorphism"><a href="#Subtype-Polymorphism" class="headerlink" title="Subtype Polymorphism"></a>Subtype Polymorphism</h2><p>在Java中，多态性是指对象可以具有多种形式或类型。在OOP中，多态性涉及如何将对象视为其自身的实例、其超类的实例、其超类的超类的实例。</p>
<p>借由多态和接口继承，我们可以尝试实现运算符重载，尽管在Java中没有专门的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OurComparable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OurComparable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> weight;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<br>        weight = w;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">another</span> <span class="hljs-operator">=</span> (Dog) o;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.weight &lt; another.weight) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.weight = another.weight) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样进行操作后，假设我们有其他类，也可以这样进行比较。如进行Dog和Cat之间的比较。</p>
<p>但是这样依然有缺陷，即强制类型转换时，可能会出错。这时我们考虑使用泛型。</p>
<p>java中已经为我们提供了接口 Comparable，故我们只需要实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Dog&gt; &#123;<br>    ...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Dog another)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.weight - another.weight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Exceptions-Iterators-Object-Methods"><a href="#Exceptions-Iterators-Object-Methods" class="headerlink" title="Exceptions, Iterators, Object Methods"></a>Exceptions, Iterators, Object Methods</h1><h2 id="Lists-Sets-ArraySet"><a href="#Lists-Sets-ArraySet" class="headerlink" title="Lists, Sets, ArraySet"></a>Lists, Sets, ArraySet</h2><p>Java为我们提供了内置的List接口和多种实现，例如Arraylist。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.List&lt;Integer&gt; L = <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>集合是唯一元素的集合，每个元素只能有一个副本，也没有顺序。Java 具有 Set 接口以及实现，例如 HashSet 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br>Set&lt;String&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>我们的目标是使用以下方法制作我们自己的集合 ArraySet ：</p>
<p>add(value) ：将值添加到集合中（如果尚不存在）</p>
<p>contains(value) ：检查 ArraySet 是否包含该值</p>
<p>size() ：返回大小</p>
<p>下面是一个框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// the next item to be added will be at position size</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySet</span><span class="hljs-params">()</span> &#123;<br>        items = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns true if this map contains a mapping for the specified key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i += <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (items[i].equals(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Associates the specified value with the specified key in this map. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (contains(x)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        items[size] = x;<br>        size += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the number of key-value mappings in this map. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h2><p>上面的框架中有一个错误，当我们将 null 添加到 ArraySet 时，我们会得到一个 NullPointerException。</p>
<p>问题在于 contains 方法，我们在其中检查 items[i].equals(x) 。如果 items[i] 处的值为 null，则我们将调用 null.equals(x) -&gt; NullPointerException。</p>
<p>在Java中，我们使用关键字 throw 来抛出异常，语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionObject</span>(parameter1, ...)<br></code></pre></td></tr></table></figure>

<p>更新后的add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Can&#x27;t add null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (contains(x)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    items[size] = x;<br>    size += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>和C++一样，我们也可以使用try、catch 语句来进行异常的捕获（此处略）</p>
<h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><p>for each 循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (object : container) &#123;<br>    <span class="hljs-comment">// body of loop</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种循环是将container中的每个object进入循环体中执行语句，支持这种循环的关键是迭代器。</p>
<p>在Java中，通过实现内置的 Iterable 接口，我们可以实现自己的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>    T <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>支持迭代器的 ArraySet 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySet</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// the next item to be added will be at position size</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySet</span><span class="hljs-params">()</span> &#123;<br>        items = (T[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns true if this map contains a mapping for the specified key.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i += <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (items[i].equals(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Associates the specified value with the specified key in this map.</span><br><span class="hljs-comment">       Throws an IllegalArgumentException if the key is null. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;can&#x27;t add null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (contains(x)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        items[size] = x;<br>        size += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Returns the number of key-value mappings in this map. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">/** returns an iterator (a.k.a. seer) into ME */</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySetIterator</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArraySetIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> wizPos;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArraySetIterator</span><span class="hljs-params">()</span> &#123;<br>            wizPos = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> wizPos &lt; size;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">returnItem</span> <span class="hljs-operator">=</span> items[wizPos];<br>            wizPos += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> returnItem;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArraySet&lt;Integer&gt; aset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;&gt;();<br>        aset.add(<span class="hljs-number">5</span>);<br>        aset.add(<span class="hljs-number">23</span>);<br>        aset.add(<span class="hljs-number">42</span>);<br><br>        <span class="hljs-comment">//iteration</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : aset) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Object-Methods"><a href="#Object-Methods" class="headerlink" title="Object Methods"></a>Object Methods</h2><p>所有类都继承自总体 Object 类。继承的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br>Class &lt;?&gt; getClass()<br><span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">Objectclone</span><span class="hljs-params">()</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span><br></code></pre></td></tr></table></figure>

<p>我们可以对这些方法进行重写。</p>
<h1 id="Lecture-12-notes-Preview-of-Project-2"><a href="#Lecture-12-notes-Preview-of-Project-2" class="headerlink" title="Lecture 12 notes: Preview of Project 2"></a>Lecture 12 notes: Preview of Project 2</h1><h2 id="Command-Line-Compliation"><a href="#Command-Line-Compliation" class="headerlink" title="Command Line Compliation"></a>Command Line Compliation</h2><p>The standard tools for executing java programs use to step process:<br>Hello.java &#x3D;&#x3D;&gt; javac (Compiler) &#x3D;&#x3D;&gt; Hello.class &#x3D;&#x3D;&gt; java (Interpreter) &#x3D;&#x3D;&gt; code</p>
<h2 id="psvm"><a href="#psvm" class="headerlink" title="psvm"></a>psvm</h2><p>Java中的main函数的基本形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，args储存了命令行参数。例如，我们有这样一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(args[<span class="hljs-number">0</span>]);<br>        System.out.println(args[<span class="hljs-number">1</span>]);<br>        System.out.println(args[<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们在命令行内执行</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>javac Hello<br><span class="hljs-variable">$ </span>java Hello x y z<br></code></pre></td></tr></table></figure>
<p>我们将会得到输出x y z。</p>
<h2 id="Git：A-Command-Line-Tool"><a href="#Git：A-Command-Line-Tool" class="headerlink" title="Git：A Command Line Tool"></a>Git：A Command Line Tool</h2><p>git是一个用C语言编写的command line program</p>
<p>git提供了一个便捷的 Version Control 工具。</p>
<p>学习Git 找到一个网站：<a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?demo=&locale=zh_CN">https://learngitbranching.js.org/?demo=&amp;locale=zh_CN</a></p>
<p>当我们每次提交(commit changes)时，git都储存了一个整个repository的copy并保存在隐藏文件夹 .git 下。</p>
<p>我们假设一个程序员经历了下面三个步骤：</p>
<ol>
<li>V1：Create readme.md</li>
<li>V2: Create some files, modify readme.md</li>
<li>V3: Modify some files, change readme.md to V1 version</li>
</ol>
<p>最自然的想法是在每次提交时都保存一份当前状态的副本，但是这种方法的缺点也是显而易见的。</p>
<p>稍加改进，我们发现每次提交时，并不是所有文件都会被修改，因此在下一次提交时，我们可以检查上一次保存的副本中是否含有相同的文件，并将本次保存的副本的相关文件用指针指向上一次的相同文件，这样就避免了同一份文件保存多次（指针只是形象的说明，Java没有指针 :P）。</p>
<p>在Java中，这种指向的一对一的键值对关系可以用map来保存。map的键为保存的文件，值记为版本号。</p>
<p>例如:</p>
<p>V1: X.java -&gt; v1, Y.java -&gt; v1<br>V2: X.java -&gt; v1, Y.java -&gt; v2<br>V3: X.java -&gt; v1, Y.java -&gt; v2, Z.java -&gt; v3<br>V4: X.java -&gt; v4, Y.java -&gt; v2, Z.java -&gt; v3, A.java -&gt; v4</p>
<p>这表示在V4中，X.java使用v4当中修改的版本，Y.java使用v2中修改的版本，以此类推。在这里，我们保存的并不是文件的内容信息，而是“Y.java V4具有和V2相同内容”这一信息。</p>
<p>接下来我们考虑下面的情景：</p>
<p>A和B同时从V3开始修改，A修改了Horse.java 而B修改了Fish.java，两人都进行了提交，这时V4应该是什么呢？</p>
<p>为了解决这一问题，git中的版本号使用提交时间来定义，这大大降低了版本冲突的问题，但仍然存在多人同时提交的可能性。</p>
<p>所以git使用基于内容确定的SHA-1 hash值作为版本号，对于同一个值，对应的Hash值也相同，本质上是一个单值函数。</p>
<p>第一步，git计算出 SHA-1 hash值<br>Hello.java &#x3D;&gt; 66ccdc645…<br>第二步，git创建一个文件夹，以前两个数字为标识<br>.git&#x2F;objects&#x2F;66<br>第三步，git储存内容在除去前两个数之后剩下部分(ccdc645…)命名的zlib文件中。</p>
<p>当文档的内容改变时，hash值也会改变，避免了版本名冲突。</p>
<p>每一个commit都包含了hash值、作者、时间和message。我们可以使用Serializable接口来实现对文件的操作。</p>
<p>在git中，我们拥有不同的分支以便储存不同的内容。在现实中，两个团队可能从同一个初始状态开始实现不同的功能，那么用不同的分支进行分隔是必要的。</p>
<p><img src="/Pictures/CS61b/02/branching.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在完成之后，我们可以使用merge命令对分支进行合并。在这一过程中，我们用到了Graph的数据结构</p>
<p><img src="/Pictures/CS61b/02/merge.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在git中，运用到了一些特殊的数据结构知识，下面是一个简短的preview</p>
<ul>
<li>Maps</li>
<li>Hashing</li>
<li>File I&#x2F;O</li>
<li>Graphs</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>使用File构造函数在Java中创造出一个File对象，并传入文件路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;dummy.txt&quot;</span>);<br><span class="hljs-comment">// Create a new file</span><br>f.createNewFile();<br><span class="hljs-comment">// Check if exists</span><br>f.exists();<br><span class="hljs-comment">// Use utils.java to write a String to a file</span><br>Utils.writeContents(f, <span class="hljs-string">&quot;Hello world!&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>创建一个代表目录的File对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;dummy&quot;</span>);<br>d.mkdir();<br></code></pre></td></tr></table></figure>

<h2 id="可序列化Serializable"><a href="#可序列化Serializable" class="headerlink" title="可序列化Serializable"></a>可序列化Serializable</h2><p>实现Serializable接口的类表明它们可以被序列化，即可以将对象转换为字节序列，以便在网络上传输或保存到持久存储中，也可以将字节序列重新转换回对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该接口没有方法；它只是为了一些特殊的 Java 类在对象上执行 I&#x2F;O 的好处而标记其子类型。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Model</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> ....;<br><span class="hljs-type">File</span> <span class="hljs-variable">outFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(saveFileName);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(outFile));<br>    out.writeObject(m);<br>    out.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException excp) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会将 m 转换为字节流并将其存储在名称存储在 saveFileName 中的文件中。然后可以使用诸如以下的代码序列来重建该对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Model m;<br><span class="hljs-type">File</span> <span class="hljs-variable">inFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(saveFileName);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inp</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(inFile));<br>    m = (Model) inp.readObject();<br>    inp.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException excp) &#123;<br>    ...<br>    m = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用 utils.java 重写代码可以使代码更加简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Model m;<br><span class="hljs-type">File</span> <span class="hljs-variable">outFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(saveFileName);<br><span class="hljs-comment">// Serializing the Model object</span><br>writeObject(outFile, m);<br><br>Model m;<br><span class="hljs-type">File</span> <span class="hljs-variable">inFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(saveFileName);<br><span class="hljs-comment">// Deserializing the Model object</span><br>m = readObject(inFile, Model.class);<br></code></pre></td></tr></table></figure>


<h1 id="Efficient-Programming"><a href="#Efficient-Programming" class="headerlink" title="Efficient Programming"></a>Efficient Programming</h1><h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><p>ADT（抽象数据结构）是由其行为而不是其实现定义的高级类型。</p>
<p>Proj1 中的 Deque 是一个具有某些行为（addFirst、addLast 等）的 ADT。但是，我们实际用来实现它的数据结构是 ArrayDeque 和 LinkedListDeque</p>
<ul>
<li>数据封装： ADT 将数据和操作封装在一起，使得数据的内部结构对外部是不可见的。</li>
<li>操作定义： ADT 定义了数据类型支持的操作，并描述了这些操作的行为。</li>
<li>独立性： ADT 的实现可以独立于使用它的程序。</li>
</ul>
<p>一些常用的 ADT 是：</p>
<ul>
<li><p>Stacks:支持元素后进先出检索的结构<br>push(int x) ：将 x 放入堆栈顶部<br>int pop() ：取出栈顶元素</p>
</li>
<li><p>Lists：一组有序的元素<br>add(int i) ：添加一个元素<br>int get(int i) ：获取索引 i 处的元素</p>
</li>
<li><p>Sets:一组无序的唯一元素（无重复）<br>add(int i) ：添加一个元素<br>contains(int i) ：返回一个布尔值，表示集合是否包含该值</p>
</li>
<li><p>Maps: 键&#x2F;值对的集合<br>put(K key, V value) ：将键值对放入映射中<br>V get(K key) ：获取key对应的值</p>
</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>ADT 的 API（应用程序编程接口）是构造函数和方法的列表以及每个构造函数和方法的简短描述。</p>
<p>API由句法和语义规范组成。</p>
<ul>
<li>规范性： API 提供了一组规范，定义了如何使用软件组件或服务。</li>
<li>抽象性： API 屏蔽了底层实现细节，使开发者可以专注于使用而不是实现细节。</li>
<li>互操作性： API 促进了不同软件系统之间的互操作性和集成。</li>
</ul>
<h2 id="Asymptotics"><a href="#Asymptotics" class="headerlink" title="Asymptotics"></a>Asymptotics</h2><p>主要概念：</p>
<ol>
<li><p>时间复杂度： 时间复杂度描述了算法执行所需时间与输入规模之间的关系。通常以大 O 表示法来表示，表示算法的渐进上界。例如，如果一个算法的时间复杂度为 O(n)，则表示算法的运行时间与输入规模成线性关系。</p>
</li>
<li><p>空间复杂度： 空间复杂度描述了算法在执行过程中所需的内存空间与输入规模之间的关系。也通常以大 O 表示法来表示。</p>
</li>
<li><p>渐进分析： 渐进分析是指对算法性能进行预测时，主要考虑随着输入规模的增长，算法的运行时间或空间占用的变化趋势。在这种分析中，我们更关注算法的增长率而不是确切的运行时间或空间。</p>
</li>
<li><p>最坏情况复杂度： 最坏情况复杂度描述了算法在最坏情况下的时间或空间开销。这给出了算法性能的一个保证，即算法在任何情况下都不会比最坏情况更差。</p>
</li>
<li><p>平均情况复杂度： 平均情况复杂度描述了算法在平均情况下的时间或空间开销。这需要考虑所有可能输入的概率分布，并计算平均性能。</p>
</li>
<li><p>最优算法： 最优算法是指在给定问题上具有最低时间复杂度或空间复杂度的算法。找到最优算法通常是解决特定问题的目标之一。</p>
</li>
</ol>
<p>这章主要介绍了时间复杂度和空间复杂度的计算，以及一些经典算法的时间复杂度分析方法，如小o、大O法等，此处不再举例说明。</p>
<h1 id="Disjoint-Sets"><a href="#Disjoint-Sets" class="headerlink" title="Disjoint Sets"></a>Disjoint Sets</h1><p>不相交集的定义：如果两个集合没有共同元素，则它们被称为不相交集合。该数据结构有两个操作：</p>
<ol>
<li>connect(x, y):连接x和y，也被称为union</li>
<li>isConnected(x, y):返回x和y是否连接</li>
</ol>
<p>不相交集数据结构具有固定数量的元素，每个元素都从自己的子集中开始。通过对某些元素 x 和 y 调用 connect(x, y) ，我们将子集合并在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-comment">/** connects two items P and Q */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>;<br><br>    <span class="hljs-comment">/** checks to see if two items are connected */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h2><p>直观上，我们可能首先考虑将不相交集表示为集合列表:<br>[{0}, {1}, {2}, {3}, {4}, {5}, {6}]<br>但这样如果我们进行connect操作，需要遍历List，时间复杂度为 $O(n)$ 。</p>
<p>所以我们考虑使用数组表示：</p>
<ul>
<li>数组的索引代表我们集合的元素。</li>
<li>索引处的值是它所属的集合编号。</li>
</ul>
<p>例如，我们将 {0, 1, 2, 4}, {3, 5}, {6} 表示为：</p>
<p><img src="/Pictures/CS61b/02/arrayset.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>执行connect操作就是把对应序号的值改为集合的编号</p>
<p>执行isConnected操作即检查序号的值是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickFindDS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickFindDS</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span>&#123;<br>        id = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[N];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>            id[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> id[p];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">qid</span> <span class="hljs-operator">=</span> id[q];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; id.length; i++)&#123;<br>            <span class="hljs-keyword">if</span> (id[i] == pid)&#123;<br>                id[i] = qid;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span>&#123;<br>        <span class="hljs-keyword">return</span> (id[p] == id[q]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h2><p>在Quick Find中，如果我们想要快速的将多个集合connect是非常困难的。</p>
<p>这时，我们考虑为每个项目分配其父集的索引编号而不是id，如果一个集合没有父项，我们为其赋值为-1.</p>
<p>这种方法支持我们将每个集合想象成一棵树。例如，我们将 {0, 1, 2, 4}, {3, 5}, {6} 表示为：</p>
<p><img src="/Pictures/CS61b/02/QuickUnion.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>对于 QuickUnion，我们定义了一个辅助函数 find(int item) ，它返回 item 所在树的根。例如，对于上面的集合， find(4) &#x3D;&#x3D; 0 、 find(1) &#x3D;&#x3D; 0 、 find(5) &#x3D;&#x3D; 3 等。每个元素都有一个唯一的root.</p>
<p>当我们想要连接两个集合时，我们只需要将A集的root连接到B集的root上，即把A集作为B集的一个branch。</p>
<p>检查两个集合是否为相连的，我们只需要检查两个集合是否具有相同的root。</p>
<p>在性能方面，利用树可以使连接变得十分简单，但相应的，当我们想要查找某一个元素时，我们需要遍历树的各个branch，时间复杂度为 $O(n)$</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickUnionDS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DisjointSets</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">QuickUnionDS</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[num];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> &#123;<br>        <span class="hljs-keyword">while</span> (parent[p] &gt;= <span class="hljs-number">0</span>) &#123;<br>            p = parent[p];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> find(p);<br>        <span class="hljs-type">int</span> j= find(q);<br>        parent[i] = j;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)</span> &#123;<br>        <span class="hljs-keyword">return</span> find(p) == find(q);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Weighted-Quick-Union-WQU"><a href="#Weighted-Quick-Union-WQU" class="headerlink" title="Weighted Quick Union (WQU)"></a>Weighted Quick Union (WQU)</h2><p>Quick Union 的改进依赖于一个关键的思路：每当我们调用 find 时，我们都必须找到树的根部。因此，树越短，速度就越快。</p>
<p>所以在我们将两个树相连时，我们选择将较小的树作为子树连接到较大的树上。</p>
<p>如何衡量树的大小？在这里，我们用树包含的元素的数量作为树的Weight。</p>
<p>基于这种方法，我们所获得的树的最大高度将会为 $logN$ ，其中 $N$ 为树所包含元素的数量。</p>
<p>我们假设有树 $T_{1},T_{2}$ ，其中 $T_{1}$ 包含了元素 $x$ ， $size(T_{2}) \ge size(T_{1})$ 。当我们合并两个tree时，我们将 $T_{1}$ 连接到 $T_{2}$ 下，这个操作使 $x$ 的深度增加1，而整个合并的树大小至少为 $T_{1}$ 的两倍，也就是说 $2^{h} &#x3D; N$ ，最大高度 $h &#x3D; \log_{2}{N}$</p>
<h2 id="Weighted-Quick-Union-with-Path-Compression"><a href="#Weighted-Quick-Union-with-Path-Compression" class="headerlink" title="Weighted Quick Union with Path Compression"></a>Weighted Quick Union with Path Compression</h2><p>在上面的方法中，每次我们调用 find(x) 时，我们必须遍历从x到root 的路径，因此在这个过程中，我们可以将访问的所有项目连接到它们的root，无需额外的渐进成本。</p>
<p>这称为摊销运行时间，我们通过这种方式使树变得更短。</p>
<h1 id="Binary-Search-Trees"><a href="#Binary-Search-Trees" class="headerlink" title="Binary Search Trees"></a>Binary Search Trees</h1><blockquote>
<p>Now we are going to learn about perhaps the most important data structure ever. –Josh Hug, CS61b</p>
</blockquote>
<p>对于搜索项目而言，有序数据结构如链表一般效率较高。但即使是已排序的列表，对于搜索项目的时间复杂度依旧为 $O(n)$ 。</p>
<p>对于数组，我们可以使用二分查找来更快的找到元素。</p>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>使用二分查找的条件：</p>
<ol>
<li>数据结构必须是有序的</li>
<li>访问数据结构的任何元素都需要恒定时间</li>
</ol>
<p>二分查找的一般步骤：</p>
<p>在二分查找算法中，通过查找中间索引 “mid” 将搜索空间分为两半</p>
<p>如果mid不是我们需要的，选择元素存在的一侧继续进行二分查找，知道找到或者空间耗尽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinarySearch</span> &#123;<br>    <span class="hljs-comment">// Returns index of x if it is present in arr[].</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> x)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = arr.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;<br> <br>            <span class="hljs-comment">// Check if x is present at mid</span><br>            <span class="hljs-keyword">if</span> (arr[m] == x)<br>                <span class="hljs-keyword">return</span> m;<br> <br>            <span class="hljs-comment">// If x greater, ignore left half</span><br>            <span class="hljs-keyword">if</span> (arr[m] &lt; x)<br>                l = m + <span class="hljs-number">1</span>;<br> <br>            <span class="hljs-comment">// If x is smaller, ignore right half</span><br>            <span class="hljs-keyword">else</span><br>                r = m - <span class="hljs-number">1</span>;<br>        &#125;<br> <br>        <span class="hljs-comment">// If we reach here, then element was</span><br>        <span class="hljs-comment">// not present</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基于有序链表，我们实现BST的步骤一般如下：</p>
<ol>
<li>将哨兵节点指向链表的中间，并更改链表之间的指向</li>
<li>判断要搜索的元素位于哪一侧</li>
<li>在一侧递归上述过程</li>
</ol>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>下面我们给出严格的树定义。<br>树由节点以及连接节点的这些边组成。</p>
<blockquote>
<p>注意：任意两个节点之间有且仅有一条路径，即不形成回路，没有连支。</p>
</blockquote>
<p>没有父节点的节点称为root，根节点。在拓扑学中，根节点实际上存在多种可能性，这里我们只任意选取一种。</p>
<p>没有子节点的节点称为叶子（leaf）</p>
<p>将其与我们之前提出的原始树结构联系起来，我们现在可以向已经存在的约束引入新的约束。这会创建更具体类型的树。</p>
<ul>
<li>Binary Trees：二叉树，规定每个节点最多只有2个子节点</li>
<li>Binary Search Trees<br>二叉搜索树，是一种二叉树，对于树中的每个节点X：</li>
</ul>
<ol>
<li>左子树中的每个键都小于X的键</li>
<li>右子树中的每个键都大于X的键</li>
</ol>
<p>基于这种特殊的性质，我们得以将二分搜索应用于这种数据结构上。</p>
<p>对于二叉搜索树的插入操作，我们基于以下的思路：</p>
<ul>
<li>首先我们搜索该节点，如果该节点已经存在，则不需要插入</li>
<li>如果我们没有找到该节点，实际上我们停止搜索的位置正好就是应该插入的位置的父节点，此时我们可以将新的leaf添加到节点的左侧或右侧。</li>
</ul>
<p>对于二叉树的删除方法，我们需要考虑三种情况：</p>
<ol>
<li>删除一片叶子</li>
<li>删除一个有一个子节点的节点d</li>
<li>删除一个有两个子节点的节点</li>
</ol>
<p>对于叶子，我们直接删除父节点和叶子之间的边即可<br>对于一个子节点，我们只需要将该节点的父节点的指针指向该节点的子节点即可<br>对于两个子节点，我们用右子树最左侧的节点（最小值）代替删除的节点或用左子树最右侧的节点（最大值）代替该节点。</p>
<p>一个简单的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BST</span>&lt;Key&gt; &#123;<br>    <span class="hljs-keyword">private</span> Key key;<br>    <span class="hljs-keyword">private</span> BST left;<br>    <span class="hljs-keyword">private</span> BST right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key, BST left, BST Right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BST</span><span class="hljs-params">(Key key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BST <span class="hljs-title function_">find</span><span class="hljs-params">(BST T, Key key)</span> &#123;<br>        <span class="hljs-keyword">if</span>(T == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(T.key == key) &#123;<br>            <span class="hljs-keyword">return</span> T;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(T.key &lt; key) &#123;<br>            <span class="hljs-keyword">return</span> find(T.right, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> find(T.left, key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BST <span class="hljs-title function_">insert</span><span class="hljs-params">(BST T, Key ik)</span> &#123;<br>        <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BST</span>(ik);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ik &lt; T.key) &#123;<br>            T.left = insert(T.left, ik);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ik &gt; T.key) &#123;<br>            T.right = insert(T.right, ik);<br>        &#125;<br>        <span class="hljs-keyword">return</span> T;<br>    &#125;<br>    <span class="hljs-comment">// A possible version, has not been tested yet.</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BST <span class="hljs-title function_">delete</span><span class="hljs-params">(BST T, Key dk)</span> &#123;<br>        <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (dk.equals(T.key)) &#123;<br>            <span class="hljs-comment">// Case 1: Node to be deleted has no children</span><br>            <span class="hljs-keyword">if</span> (T.left == <span class="hljs-literal">null</span> &amp;&amp; T.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-comment">// Case 2: Node to be deleted has only one child</span><br>            <span class="hljs-keyword">if</span> (T.left == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> T.right;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (T.right == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> T.left;<br>            &#125;<br>            <span class="hljs-comment">// Case 3: Node to be deleted has two children</span><br>            <span class="hljs-type">Key</span> <span class="hljs-variable">minKey</span> <span class="hljs-operator">=</span> findMin(T.right);<br>            T.key = minKey;<br>            T.right = delete(T.right, minKey);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dk &lt; T.key) &#123;<br>            T.left = delete(T.left, dk);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            T.right = delete(T.right, dk);<br>        &#125;<br>        <span class="hljs-keyword">return</span> T;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Key <span class="hljs-title function_">findMin</span><span class="hljs-params">(BST T)</span> &#123;<br>        <span class="hljs-keyword">while</span> (T.left != <span class="hljs-literal">null</span>) &#123;<br>            T = T.left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> T.key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Tree-traversal"><a href="#Tree-traversal" class="headerlink" title="Tree traversal"></a>Tree traversal</h2><p>对于树，我们有这样四种遍历的方式</p>
<ol>
<li>前序遍历（根优先遍历，即对于每个树和子树，按照根-左树-右树的顺序遍历）</li>
<li>中序遍历（左树-根-右树）</li>
<li>后序遍历（左树-右树-根）</li>
<li>层次遍历（具有相同深度的称为一层）</li>
</ol>
<p>这里我们实现中序遍历:</p>
<p>我们在迭代器中使用一个栈来辅助遍历。在将元素压入栈中的过程中，我们需要注意以下几点：</p>
<ol>
<li><p>找到左子树的最左节点：首先，我们需要找到当前节点的左子树的最左节点。这个节点是中序遍历中的第一个要访问的节点。</p>
</li>
<li><p>将节点压入栈中：一旦找到了左子树的最左节点，我们将该节点压入栈中。</p>
</li>
<li><p>更新当前节点：然后，我们将当前节点移动到其右子树。如果右子树不为空，我们继续重复步骤 1 和 2。</p>
</li>
<li><p>重复直到完成：我们重复执行上述步骤，直到栈为空。当栈为空时，说明 BST 中的所有节点都已经遍历完成。</p>
</li>
</ol>
<p>下面是一个例子：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">    5</span><br><span class="hljs-code">   / \</span><br><span class="hljs-code">  3   8</span><br><span class="hljs-code"> / \ / \</span><br><span class="hljs-code">2  4 7  9</span><br></code></pre></td></tr></table></figure>
<p>首先，我们将根节点 5 压入栈中，并且将根节点的左子树全部压入栈中，直到左子树的最左节点 2。此时，栈中的元素为 [2, 3, 5]。</p>
<p>接着，我们开始执行迭代器的 next() 方法。在 next() 方法中，我们首先弹出栈顶节点 2，然后将其右子节点 null 压入栈中。此时，栈中的元素为 [3, 5]。</p>
<p>继续执行 next() 方法，我们弹出栈顶节点 3，返回 3。然后，将其右子节点 4 压入栈中。此时，栈中的元素为 [4, 5]。</p>
<p>再次执行 next() 方法，我们弹出栈顶节点 4，返回 4。此时，栈中的元素为 [5]。</p>
<p>继续执行 next() 方法，我们弹出栈顶节点 5，返回 5。然后，将其右子节点 8 压入栈中，并将右子树的所有左子节点全部压入栈中，直到左子树的最左节点 7。此时，栈中的元素为 [7, 8]。</p>
<p>继续执行 next() 方法，我们弹出栈顶节点 7，返回 7。然后，将其右子节点 null 压入栈中。此时，栈中的元素为 [8]。</p>
<p>最后，我们弹出栈顶节点 8，返回 8。然后，将其右子节点 9 压入栈中，并且将右子节点的所有左子节点全部压入栈中，直到左子树的最左节点 9。此时，栈中的元素为 [9]。</p>
<p>最终，我们执行 next() 方法，弹出栈顶节点 9，返回 9。此时，栈为空，遍历结束。</p>
<p>通过这个过程，我们按照中序遍历的顺序遍历了二叉搜索树中的所有节点，迭代器的 next() 方法成功返回了所有节点的键值。</p>
<h2 id="Tree-Height"><a href="#Tree-Height" class="headerlink" title="Tree Height"></a>Tree Height</h2><p>在最好情况下，search操作的时间为 $\Theta (\log{}{N})$ ，但最差情况下可以达到 $\Theta (n)$ 。</p>
<ul>
<li>depth: 节点与根之间的链接数</li>
<li>height: 树的最低深度（深度最大）</li>
<li>average depth：平均深度<br>树的高度决定了最坏情况下的运行时间，因为在最坏情况下我们需要的节点在树的底部。<br>平均深度决定了平均运行时间。</li>
</ul>
<h2 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h2><p>当我们插入新数据时，我们总是会将新数据插入到原来的叶子上，这样便造成了树的高度增加。更严重的是，当我们的数据呈现出连续的特点时，我们会沿着一条路线不断向下，导致整棵树的结构试去平衡，也使算法效率降低。</p>
<p>于是我们便有了这样一个想法：当我们添加节点时，永远不要添加叶节点，而是将原有的叶节点扩充，即一个节点依次存放多于一个数据。</p>
<p>这样做的确使结构平衡，减小了高度，但是在新添加的数据量级较大时，并没有降低复杂度。</p>
<p>于是我们将添加的数据继续分离，将中间的一部分沿树枝向上添加到父节点中，使得整个树更加平衡。这样，对于每一个节点，我们都可以拥有含有两个元素的子节点，并保持节点之间的有序排列，这便是B树的定义。</p>
<p>我们主要讨论 2-3 树，即一个节点可以最多包含两个元素，三个子节点。</p>
<p>B树的主要特点包括：</p>
<ol>
<li>每个节点最多有m个子节点。</li>
<li>除了根节点和叶节点外，每个节点至少有⌈m&#x2F;2⌉个子节点。</li>
<li>根节点至少有两个子节点，除非它是一个叶节点。</li>
<li>所有叶节点都出现在同一层级。</li>
<li>一个非叶节点如果有k个子节点，那么它包含k-1个键。每个内部节点的键作为分隔值，将其子树分开。</li>
</ol>
<h3 id="B-Tree-Deletion"><a href="#B-Tree-Deletion" class="headerlink" title="B-Tree Deletion"></a>B-Tree Deletion</h3><p><strong>CASE1：</strong>邻近的兄弟节点有多个Key<br><img src="/Pictures/CS61b/02/case1A.png" srcset="/img/loading.gif" lazyload alt="case1"></p>
<p>这种情况下，我们用父节点填充删除节点，用邻近兄弟节点的较小Key填充父节点.</p>
<p><img src="/Pictures/CS61b/02/1Asolve.png" srcset="/img/loading.gif" lazyload alt="solution"></p>
<p><strong>CASE2：</strong>父节点含有两个Key，邻近的兄弟节点只有一个。</p>
<p><img src="/Pictures/CS61b/02/case2.png" srcset="/img/loading.gif" lazyload alt="case2"></p>
<p>在这种情况下，父节点的左值分配到左孩子，右值分配到右孩子，中间的子节点的两个孙节点分别分配到其余节点下。</p>
<p><img src="/Pictures/CS61b/02/2solution.png" srcset="/img/loading.gif" lazyload alt="solution"></p>
<p><strong>CASE3：</strong>父节点和邻近兄弟节点均只有一个Key</p>
<p><img src="/Pictures/CS61b/02/case3.png" srcset="/img/loading.gif" lazyload alt="case3"></p>
<h3 id="Tree-Rotation"><a href="#Tree-Rotation" class="headerlink" title="Tree Rotation"></a>Tree Rotation</h3><p>在上面的算法中，我们多次用到了CASE1中类似于“旋转”的操作。接下来我们就来正式的定义这种操作并用算法实现。</p>
<p>The formal definition of rotation is:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BTree</span> &#123;<br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(Node h)</span> &#123;<br>        <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.left);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.left;<br>        h.left = x.right;<br>        x.right = h;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br><span class="hljs-comment">// make a right-leaning link lean to the left</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">rotateLeft</span><span class="hljs-params">(Node h)</span> &#123;<br>        <span class="hljs-comment">// assert (h != null) &amp;&amp; isRed(h.right);</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> h.right;<br>        h.right = x.left;<br>        x.left = h;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/Pictures/CS61b/02/rotation.png" srcset="/img/loading.gif" lazyload alt="rotation"></p>
<p>通过基础的旋转操作，我们可以实现简单的节点重构。</p>
<h2 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h2><p>2-3 树的想法非常好，但实际上很难实现，于是我们考虑创建一种同时使用BST和2-3树的结构的新的树。</p>
<p>我们首先考虑如何将2-3树转换为BST。</p>
<p>对于只有两个子节点的2-3树，我们已经有了BST结构，因此不需要进行修改；但是对于有三个子节点的树，我们首先要做的便是创建一个“粘合节点”，它不保存任何信息，仅用于表明它的两个子节点实际上时一个节点的一部分。</p>
<p>然而，这是一个非常不优雅的解决方案，因为我们占用了更多的空间，而且代码也很难看。因此，我们将使用粘合链接而不是使用粘合节点！</p>
<p>我们选择使左侧元素成为右侧元素的子元素。这会产生一棵左倾树。我们通过将链接设为红色来表明它是粘合链接。正常链接是黑色的。因此，我们将这些结构称为左倾红黑树(LLRB)。</p>
<p>2-3树和LLRB之间存在一一对应的双射关系。</p>
<p><img src="/Pictures/CS61b/02/LLRB.png" srcset="/img/loading.gif" lazyload alt="LLRB"></p>
<p>注意：要构成有效的红黑树，需要满足以下条件：</p>
<ol>
<li>每个节点只能有不多于一个红色链接</li>
<li>每条从leaf 到 root 的路径具有相同的黑色链接数量。</li>
<li>若原本2-3树的高度为 $H$ ，LLRB的高度不超过 $2H+1$ 。</li>
</ol>
<h3 id="Tree-Insertion"><a href="#Tree-Insertion" class="headerlink" title="Tree Insertion"></a>Tree Insertion</h3><p>向红黑树中插入节点，需要解决以下几个问题：</p>
<ol>
<li>插入的颜色：在2-3树中，我们总是通过添加到叶节点来插入，所以我们添加的链接应该是红色链接。</li>
</ol>
<p><img src="/Pictures/CS61b/02/insert_color.png" srcset="/img/loading.gif" lazyload alt="Task1"></p>
<ol start="2">
<li>插入方向：我们使用的是LLRB，这意味着我们永远不可能拥有右侧的红色链接，如果需要在右侧插入，我们需要进行必要的旋转操作。</li>
</ol>
<p><img src="/Pictures/CS61b/02/insert_right.png" srcset="/img/loading.gif" lazyload alt="Task2"></p>
<ol start="3">
<li>引入暂时的 <em>4节点</em> 解决问题</li>
</ol>
<p><img src="/Pictures/CS61b/02/4node.png" srcset="/img/loading.gif" lazyload alt="Task3"></p>
<p>之后我们利用 <em>flip</em> 操作来进行规范化操作。</p>
<p><img src="/Pictures/CS61b/02/flip.png" srcset="/img/loading.gif" lazyload alt="Task4"></p>
<p>抽象代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">put</span><span class="hljs-params">(Node h, Key key, Value val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-literal">null</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, val, RED); &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> key.compareTo(h.key);<br>    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) &#123; h.right = put(h.right, key, val); &#125;<br>    <span class="hljs-keyword">else</span>              &#123; h.val   = val;                    &#125;<br><br>    <span class="hljs-keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;<br>    <span class="hljs-keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; <br><br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><h2 id="DataIndexedIntegerSet"><a href="#DataIndexedIntegerSet" class="headerlink" title="DataIndexedIntegerSet"></a>DataIndexedIntegerSet</h2><p>对于我们已经学习到的数据结构，我们需要寻找某一元素时，都需要遍历整个结构。这样通常会花费 $O(n)$ 运行时甚至更多。于是我们考虑设计这样一个数据结构，让寻找元素的时间变为 $O(1)$ 。</p>
<p>于是我们考虑这样一种数据结构：我们创建一个非常大的数组，存放boolean类型的数据，<strong>将数组的 index 作为数据的值</strong>。初始时我们将元素设置为<em>false</em>，代表没有存放对应序号的数据。在添加数据时，只需要将对应位置的元素更改为<em>true</em>即可。这样，我们的<em>search</em>和<em>contains</em>操作都将是 $O(1)$ 复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataIndexedIntegerSet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] present;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataIndexedIntegerSet</span><span class="hljs-params">()</span> &#123;<br>        present = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">200000000</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        present[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">return</span> present[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显然，这个数据结构占用空间大、存储数据类型单一、浪费资源，但是却为我们提供了一个很好的思路。</p>
<h2 id="DataIndexedStringSet"><a href="#DataIndexedStringSet" class="headerlink" title="DataIndexedStringSet"></a>DataIndexedStringSet</h2><p>接下来我们尝试在数据结构中插入<em>String</em>类型的数据。</p>
<p>基于上面的思想，我们也考虑使用一个算法将每一个String转化成唯一的一个Integer。比如我们为每一个英文字母和符号分配一个数值，用数值加和得出的结果来代表这个单词。</p>
<p>这里很自然的我们想到利用<strong>ASCII码</strong>来处理。</p>
<p>在算法方面，我们考虑借鉴进制的定义，比如十进制利用0到9的十个数字表示出所有自然数。我们以 126 为基，这样 “cat” 便可以表示为：</p>
<p>$$cat &#x3D; char(c)\times 126^{2}+char(a)\times 126^{1}+char(t)\times 126^{0}$$</p>
<p>其中char代表对应的ASCII码值。</p>
<p>这样，我们便可以使用int代替String，接下来就可以用int进行存储。</p>
<p>但是，如果我们想要储存中文，最大的可能符号有 <strong>40959</strong> 种，意味着我们需要一个大于39万亿的数组存储，这显然是不现实的！</p>
<h2 id="Hash-Code"><a href="#Hash-Code" class="headerlink" title="Hash Code"></a>Hash Code</h2><p>对于小范围的哈希值，我们可以使用一个数组来区分每个哈希值。也就是说，数组中的每个索引都代表一个唯一的哈希值。如果我们的指数很小并且接近于零，那么这种方法很有效。</p>
<p>假设我们只想支持长度为 10 的数组，以避免分配过多的内存。此时，我们可以依靠取模运算实现这一点。</p>
<p>所以要创建有效的哈希码，我们需要考虑下述维度：</p>
<ol>
<li>Deterministic:确定性，两个相等的对象 A 和 B ( A.equals(B) &#x3D;&#x3D; true ) 的 hashCode() 函数具有相同的哈希码。</li>
<li>Consistent:每次在对象的同一实例上调用 hashCode() 函数时，它都会返回相同的整数。</li>
</ol>
<p>在此基础上，如果需要拥有高效的哈希码，我们需要进一步考虑以下问题：</p>
<ol>
<li>hashCode() 函数必须有效。</li>
<li>hashCode() 函数值应尽可能均匀地分布在所有整数的集合上。</li>
<li>hashCode() 函数的计算速度应该相对较快[理想情况下为 $O(1)$ 常数时间数学运算]</li>
</ol>
<p>由于数据溢出等特殊情况，出现冲突是不可避免的。对于这种情况，我们有以下方式进行处理：</p>
<ol>
<li><p>线性探测：将冲突键存储在数组中的其他位置，可能存储在下一个开放数组空间中。这种方法可以通过分布式哈希表看到。</p>
</li>
<li><p>外部链接：一个更简单的解决方案是将具有相同哈希值的所有键一起存储在它们自己的集合中，例如 <em>LinkedList</em> 。这种共享单个索引的条目集合称为<strong>存储桶</strong>。</p>
</li>
</ol>
<p>对于哈希表，一旦表中数据越来越倾向于饱和，发生冲突和错误的可能性就越大。因此，动态调整哈希表的大小是十分必要的。</p>
<p>为了跟踪哈希表的填充程度，我们定义了术语负载因子，它是插入的元素数量与数组总物理长度的比率。</p>
<p>$$load \ factor&#x3D;\frac{size()}{array.length}$$</p>
<p>对于我们的哈希表，我们将定义允许的最大负载因子。如果添加另一个键值对会导致负载因子超过指定的最大负载因子，则应调整哈希表的大小。这通常是通过将基础数组长度加倍来完成的。 Java 默认的最大负载因子是 0.75，它在合理大小的数组和减少冲突之间提供了良好的平衡。</p>
<h1 id="Heaps-and-Priority-Queues"><a href="#Heaps-and-Priority-Queues" class="headerlink" title="Heaps and Priority Queues"></a>Heaps and Priority Queues</h1><p>在二叉搜索树BST中，我们能够高效地搜索到需要的元素，只需要 $\log{}{N}$ 的时间复杂度。如果我们更加关心快速找到最小或最大元素而不是快速搜索怎么办？</p>
<h2 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h2><p>我们先来看优先队列的接口：在我们定义的最小优先队列中，我们只能与队列中的最小元素进行交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** (Min) Priority Queue: Allowing tracking and removal of </span><br><span class="hljs-comment">  * the smallest item in a priority queue. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MinPQ</span>&lt;Item&gt; &#123;<br>    <span class="hljs-comment">/** Adds the item to the priority queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Item x)</span>;<br>    <span class="hljs-comment">/** Returns the smallest item in the priority queue. */</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getSmallest</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/** Removes the smallest item from the priority queue. */</span><br>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">removeSmallest</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">/** Returns the size of the priority queue. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们考虑使用已经学习过的数据结构进行实现：</p>
<ol>
<li>Ordered Array 有序数组</li>
<li>BST 二叉搜索树</li>
<li>HashTable 哈希表</li>
</ol>
<h2 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h2><p>经过比较，我们发现BST具有已知的最佳运行效率。我们考虑在BST的基础上继续进行改进，可以进一步提高这些操作的运行时间效率。</p>
<p>我们定义 Heap 的数据结构，这是一种<strong>完全二叉树</strong>，即具有：</p>
<ol>
<li>堆序性质（Heap Property）：在堆中，对于每个节点 i，父节点的键值小于或等于（小顶堆）或大于或等于（大顶堆）其子节点的键值。</li>
<li>完全二叉树结构（Complete Binary Tree Structure）：堆是一种完全二叉树，即除了最底层节点，其他层的节点都是满的，最底层节点都尽可能地靠左排列。</li>
</ol>
<p>堆分为两种类型：最小堆和最大堆。在最小堆中，父节点的键值始终小于或等于其子节点的键值；而在最大堆中，父节点的键值始终大于或等于其子节点的键值。</p>
<p>Java实现最小优先队列的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinPriorityQueue</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;T&gt; heap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinPriorityQueue</span><span class="hljs-params">()</span> &#123;<br>        heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item)</span> &#123;<br>        heap.offer(item);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">extractMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> heap.poll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">peekMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> heap.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不调用封装好的类，我们可以用计数器的思想实现优先级。即：计数器在每次插入项目时都会递增。最近插入的项目始终具有更高的优先级，因此它们将首先被删除。</p>
<p>一个可能的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountingPriorityQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Element&lt;T&gt;&gt; queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountingPriorityQueue</span><span class="hljs-params">()</span> &#123;<br>        queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        count = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(T item, <span class="hljs-type">int</span> priority)</span> &#123;<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>&lt;&gt;(item, priority, count++));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">extractMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (queue.isEmpty())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        Element&lt;T&gt; minElement = queue.poll();<br>        <span class="hljs-keyword">return</span> minElement.item;<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个内部类来表示带有优先级和插入顺序的元素</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Element</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Element&lt;E&gt;&gt; &#123;<br>        E item;<br>        <span class="hljs-type">int</span> priority;<br>        <span class="hljs-type">int</span> insertionOrder;<br><br>        Element(E item, <span class="hljs-type">int</span> priority, <span class="hljs-type">int</span> insertionOrder) &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.priority = priority;<br>            <span class="hljs-built_in">this</span>.insertionOrder = insertionOrder;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Element&lt;E&gt; other)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.priority != other.priority) &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.insertionOrder, other.insertionOrder);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>一般而言，Heap有如下的性质使得它能很方便地实现优先队列的数据结构：</p>
<ol>
<li><p>高效的插入和删除操作：堆的插入和删除操作的时间复杂度为 $O(log n)$ ，其中n是堆中元素的数量。这使得堆非常适合用于实现优先队列，因为在优先队列中，我们经常需要插入和删除元素。</p>
</li>
<li><p>快速访问最小（或最大）元素：堆允许在常数时间内 $O(1)$ 访问堆顶元素，这是因为堆的根节点始终是最小（或最大）的元素。这对于优先队列来说非常重要，因为我们经常需要知道当前队列中优先级最高的元素。</p>
</li>
<li><p>自动维护顺序：堆具有自我调整的性质，即在插入或删除元素后，堆会自动调整其结构以保持堆的性质。这意味着我们不需要手动维护堆的顺序，从而简化了代码实现。</p>
</li>
<li><p>支持动态大小：堆可以动态地调整大小，因此可以容纳任意数量的元素。这使得堆非常适合用于实现优先队列，因为我们通常不知道在队列中需要存储多少元素。</p>
</li>
</ol>
<p>一些有意思的点：<br>按降序排序的数组是最大堆（根是最大值，值按级别顺序递减）。</p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><p>一般来说，图由两部分组成：</p>
<ol>
<li>一组节点</li>
<li>一组边，有向或无向</li>
</ol>
<p>所有树也是图，但并非所有图都是树。</p>
<p>对于图，我们一般考虑下列问题：</p>
<ol>
<li>路径：顶点 s 和 t 之间是否存在路径？</li>
<li>连通性：图是否连通，即所有顶点之间是否存在路径？</li>
<li>双连通性：是否存在删除某个顶点会断开图的连接？</li>
<li>最短 s-t 路径：顶点 s 和 t 之间的最短路径是多少？</li>
<li>环路检测：图表中是否存在环路？</li>
<li>同构：两个图是否同构（同构图）？</li>
</ol>
<p>总体来说，最根本的还是一个问题：我们如何遍历图？</p>
<h2 id="Graph-traversal"><a href="#Graph-traversal" class="headerlink" title="Graph traversal"></a>Graph traversal</h2><p>我们先关注第一个问题:如何确定两个节点 $s$ 和 $t$ 之间是否存在路径.</p>
<p>我们考虑一个函数：它接受两个顶点并返回两者之间是否存在路径。实现这个函数，我们可以以第一个节点为参考节点，然后访问他的一个邻居节点并将自己标记为已查找。之后对第二个节点递归的调用该函数知道找到目标节点或遍历完整个路径（所有节点均被标记）。</p>
<p>具体而言，可以拆解为以下步骤：</p>
<ol>
<li>从图中的某个顶点开始遍历，将该顶点标记为已访问。</li>
<li>递归地对该顶点的未访问邻居顶点进行深度优先遍历。</li>
<li>重复步骤2，直到该顶点的所有邻居顶点都被访问过。</li>
<li>回溯到上一个顶点，重复步骤2和步骤3，直到图中的所有顶点都被访问过。</li>
</ol>
<p>事实上，这正是图的<strong>深度优先遍历算法（Depth-First Search，DFS）</strong>。我们可以尝试用伪代码来实现一下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">DFS(vertex):<br><span class="hljs-code">    将vertex标记为已访问</span><br><span class="hljs-code">    访问vertex</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    对于vertex的每个未访问的邻居neighbor：</span><br><span class="hljs-code">        如果neighbor未被访问：</span><br><span class="hljs-code">            递归调用DFS(neighbor)</span><br></code></pre></td></tr></table></figure>

<p>我们也可以用栈来优化递归操作，在这里不做展示。</p>
<p>深度优先遍历算法的时间复杂度为 $O(V + E)$ ，其中 $V$ 是顶点的数量，$E$ 是边的数量。</p>
<p>事实上，我们也能用另一种思路解决这个问题：<br>我们先将第一个节点的所有邻居访问完成，然后逐层向下地访问其它节点。这一思想称为<strong>广度优先搜索（Breadth-First Search，BFS）</strong>。我们一般使用队列来进行实现：</p>
<ol>
<li>在遍历的过程中，先将起始顶点加入队列，然后重复以下步骤直到队列为空</li>
<li>弹出队列中的顶点，并访问该顶点。</li>
<li>遍历该顶点的所有邻居顶点，如果某个邻居顶点未被访问过，则将其加入队列，并标记为已访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">BFS(Graph G, Vertex start):<br>    <span class="hljs-comment">// 初始化队列并将起始顶点入队</span><br>    Queue queue<br>    queue.enqueue(start)<br>    <span class="hljs-comment">// 标记起始顶点为已访问</span><br>    mark start as visited<br>    <br>    <span class="hljs-comment">// 循环直到队列为空</span><br>    <span class="hljs-keyword">while</span> queue is not empty:<br>        <span class="hljs-comment">// 弹出队列中的顶点，并访问该顶点</span><br>        current = queue.dequeue()<br>        visit current<br>        <br>        <span class="hljs-comment">// 遍历当前顶点的所有邻居顶点</span><br>        <span class="hljs-keyword">for</span> each neighbor of current:<br>            <span class="hljs-comment">// 如果邻居顶点未被访问过</span><br>            <span class="hljs-keyword">if</span> neighbor is not visited:<br>                <span class="hljs-comment">// 将邻居顶点标记为已访问，并入队</span><br>                mark neighbor as visited<br>                queue.enqueue(neighbor)<br></code></pre></td></tr></table></figure>

<h2 id="Graph-Representing"><a href="#Graph-Representing" class="headerlink" title="Graph Representing"></a>Graph Representing</h2><p>表示图的方式有很多，常见的是用邻接矩阵(Adjacency Matrix)和邻接表(Adjacency Lists)。</p>
<h3 id="Adjacency-Matrix"><a href="#Adjacency-Matrix" class="headerlink" title="Adjacency Matrix"></a>Adjacency Matrix</h3><p>使用二维数组。有一条边将顶点 s 连接到 t ，前提是相应的单元格是 1 （表示 true ）。请注意，如果图是无向的，则邻接矩阵将在其对角线上（从左上角到右下角）对称。  </p>
<h3 id="Adjacency-Lists"><a href="#Adjacency-Lists" class="headerlink" title="Adjacency Lists"></a>Adjacency Lists</h3><p>维护一个列表数组，按顶点号索引。如果存在从 s 到 t 的边，则数组索引 s 处的列表将包含 t 。</p>
<h2 id="Shortest-Paths–Dijkstra’s-Algorithm"><a href="#Shortest-Paths–Dijkstra’s-Algorithm" class="headerlink" title="Shortest Paths–Dijkstra’s Algorithm"></a>Shortest Paths–Dijkstra’s Algorithm</h2><p>Dijkstra算法是计算机科学中的一种流行算法，用于在图中找到节点之间的最短路径，特别是在具有非负边权重的图中。<br>该算法通过迭代地选择从源节点开始的已知距离最小的节点，并在发现更短路径时更新其相邻节点的距离来运作。它通过维护一个优先队列（通常用最小堆实现）来高效地选择下一个要探索的节点。</p>
<p>以下是Dijkstra算法的步骤概述：</p>
<ol>
<li><p>初始化： 将源节点的距离设置为0，将所有其他节点的距离设置为无穷大。初始化一个空的优先队列（或最小堆），用于按距离排序的节点。</p>
</li>
<li><p>选择下一个节点： 从优先队列中提取具有最小距离的节点。最初，这将是源节点。</p>
</li>
<li><p>更新相邻节点： 对于当前节点的每个相邻节点，计算通过当前节点到源节点的距离。如果此距离比先前已知的距离更短，则更新相邻节点的距离并更新其父节点（找到最短路径的节点）。将更新后的相邻节点插入优先队列。</p>
</li>
<li><p>重复： 重复步骤2和3，直到所有节点都被处理或达到目标节点。</p>
</li>
<li><p>最短路径重建： 一旦到达目标节点或所有节点都已处理，就可以通过在算法执行过程中存储的父指针回溯从目标节点到源节点，重建从源到目标的最短路径。</p>
</li>
</ol>
<p>下面是一个可能的伪代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Dijkstra</span>(<span class="hljs-params">graph, source</span>):<br>    dist[source] = <span class="hljs-number">0</span> // 到源节点的距离为<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> each vertex v <span class="hljs-keyword">in</span> graph:<br>        <span class="hljs-keyword">if</span> v ≠ source:<br>            dist[v] = ∞ // 到其他节点的距离初始化为无穷大<br>        add v to priority queue <span class="hljs-keyword">with</span> priority dist[v]<br>    <br>    <span class="hljs-keyword">while</span> priority queue <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty:<br>        u = remove vertex <span class="hljs-keyword">with</span> minimum dist[u] <span class="hljs-keyword">from</span> priority queue<br>        <span class="hljs-keyword">for</span> each neighbor v of u:<br>            alt = dist[u] + weight(u, v) // 计算通过u到达v的距离<br>            <span class="hljs-keyword">if</span> alt &lt; dist[v]: // 如果通过u到达v的距离更短<br>                dist[v] = alt // 更新到v的最短距离<br>                update priority queue <span class="hljs-keyword">with</span> new priority dist[v] // 更新优先队列中v的优先级<br></code></pre></td></tr></table></figure>

<h1 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h1><p>最小生成树（Minimum Spanning Tree，MST）是一种在连通加权图中找到的特殊树形结构，它包含了图中的所有顶点，并且是一个树，没有环路，同时权重之和最小。</p>
<p>割集（Cut Set）是指一个图中的边集合，当这些边被移除后，原本连通的图被分割成两个或多个不相连的子图。换句话说，割集是一组边，它们的移除会使得图中的顶点失去连接，导致图分裂成多个连通分量。</p>
<p>连支（Connected Components）是指图中的一组顶点，它们之间有路径相连，并且没有其他的顶点与这些顶点相连。连支是由顶点组成的集合，用于描述图的连通性。</p>
<p>寻找连通图的最小生成树，一般而言有两种算法，均基于贪心思想：</p>
<ol>
<li>Kruskal 算法</li>
<li>Prim 算法</li>
</ol>
<p>时间复杂度均为 $O(E\log{}{V})$ 。</p>
<h2 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h2><p>基本思想：<br>Prim 算法也是一种贪心策略，从一个初始顶点开始，逐步扩展最小生成树，每次选择与当前最小生成树相连的权重最小的边，并且不会形成环路。</p>
<p>Prim 算法在稠密图中效果更好，适用于边的数量与顶点数量相当的情况。</p>
<p>步骤：</p>
<ol>
<li>选择一个起始顶点作为初始树。</li>
<li>将与初始树相连的边加入候选边集合中。</li>
<li>从候选边集合中选择权重最小的边，将其加入最小生成树，并将其所连接的顶点加入最小生成树的顶点集合中。</li>
<li>重复步骤3，直到最小生成树包含了图中的所有顶点。</li>
</ol>
<h2 id="Kruskal’s-Algorithm"><a href="#Kruskal’s-Algorithm" class="headerlink" title="Kruskal’s Algorithm"></a>Kruskal’s Algorithm</h2><p>基本思想：<br>Kruskal 算法基于贪心策略，每次选择权重最小的边，如果这条边不形成环路，则将其加入最小生成树。</p>
<p>Kruskal 算法对于稀疏图效果较好，适用于边的数量远远大于顶点数量的情况。</p>
<p>步骤：</p>
<ol>
<li>将图中的所有边按照权重从小到大排序。</li>
<li>依次从排序后的边集合中选取边，如果选取的边不会形成环路（即加入这条边后不会出现环路），则将其加入最小生成树。</li>
<li>重复步骤2，直到最小生成树中包含了图中的所有顶点为止。</li>
</ol>
<h1 id="Mutidimensional-Data"><a href="#Mutidimensional-Data" class="headerlink" title="Mutidimensional Data"></a>Mutidimensional Data</h1><p>对于一维数据的存储，我们有十分简便的比较大小的方式。但是对于二维乃至于多维的数据，如果我们想要分类，一个依据是每个维度进行大小的比较，这时候就需要增加树的节点个数来表示不同的区间。</p>
<h2 id="Quadtree"><a href="#Quadtree" class="headerlink" title="Quadtree"></a>Quadtree</h2><p>四叉树（Quadtree）是一种用于表示二维空间的树形数据结构，它将二维空间递归地划分为四个象限，每个象限可以继续划分为四个子象限，以此类推。四叉树常用于表示和管理二维数据。</p>
<ol>
<li>空间划分：四叉树将二维空间划分为四个象限：左上、右上、左下、右下。每个象限可以继续划分为四个子象限，以此类推，直到达到某个终止条件。</li>
<li>节点结构：四叉树的节点包含四个指针，分别指向其四个子节点。如果一个节点没有子节点，则称为叶子节点。叶子节点通常包含相应区域内的数据。</li>
<li>查询操作：四叉树可以快速进行区域查询和范围查询。区域查询用于查找落在给定区域内的所有数据点，而范围查询用于查找与给定点距离不超过一定范围内的所有数据点。</li>
<li>空间分析：四叉树可以用于进行空间分析，如判断两个区域是否相交、计算区域的面积、查找最近邻点等。</li>
</ol>
<h2 id="K-D-Trees"><a href="#K-D-Trees" class="headerlink" title="K-D Trees"></a>K-D Trees</h2><p>KD 树（K-Dimensional Tree）是一种二叉树数据结构，用于对 k 维空间中的数据进行分割和组织。KD 树常被用于对多维数据进行搜索、范围查询和最近邻搜索等操作。</p>
<ol>
<li>空间划分：KD 树通过递归地将 k 维空间划分为轴对齐的超矩形区域。每个节点代表一个超矩形区域，其子节点对应于该区域被分割后的子区域。</li>
<li>轴选择：在构建 KD 树时，每次选择一个坐标轴作为切分的依据。通常，轴的选择是交替进行的，比如在二维空间中就是交替选择 x 轴和 y 轴。</li>
<li>节点结构：KD 树的节点包含一个数据点以及指向左右子节点的指针。根据选择的切分轴，左子节点的数据点在该轴上小于当前节点的值，右子节点的数据点在该轴上大于当前节点的值。</li>
<li>搜索操作：KD 树可以用于范围查询和最近邻搜索。范围查询用于查找落在给定超矩形区域内的所有数据点，最近邻搜索用于查找离给定点最近的数据点。</li>
</ol>
<p>构建 KD 树的步骤：</p>
<ol>
<li>选择初始轴（通常是坐标轴）。</li>
<li>根据选定的轴，找到中位数，将数据集分为两部分。</li>
<li>递归地构建左右子树，重复步骤 1 和步骤 2，直到每个区域只包含一个数据点为止。</li>
</ol>
<p>最近邻搜索算法（Nearest Neighbor Search）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">NNS</span>(<span class="hljs-params">root, target</span>):<br>    best_node = <span class="hljs-literal">None</span><br>    best_distance = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">nearest</span>(<span class="hljs-params">node</span>):<br>        <span class="hljs-keyword">if</span> node = <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span><br>        axis = node.axis<br>        <span class="hljs-comment"># 这里的distance一般指欧氏距离</span><br>        current_distance = distance(node, target)<br>        <span class="hljs-keyword">if</span> current_distance &lt; best_distance:<br>            best_node = node<br>            best_distance = current_distance<br>        <span class="hljs-keyword">elif</span> target[axis] &lt; node[axis]:<br>            nearest(node.left)<br>            <span class="hljs-keyword">if</span> target[axis] + best_distance &gt;= node[axis]:<br>                nearest(node.right)<br>        <span class="hljs-keyword">else</span>:<br>            nearest(node.right)<br>            <span class="hljs-keyword">if</span> target[axis] - best_distance &lt;= node[axis]:<br>                nearest(node.left)<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/CS61b/" class="category-chain-item">CS61b</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Fabulous の CS~61b 奇妙⭐冒险记</div>
      <div>https://fabulous1496.github.io/2024/02/29/CS61B学习笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Fabulous</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月29日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/04/RNN/" title="RNN——循环神经网络">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RNN——循环神经网络</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/25/06-%E6%96%B0%E9%97%BB%E4%B8%BB%E9%A2%98%E5%88%86%E7%B1%BB/" title="新闻主题分类">
                        <span class="hidden-mobile">新闻主题分类</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"CjZvdepCB7OjY30a6oge7W6x-gzGzoHsz","appKey":"ErsGn5pjObFn129dKnLC8esg","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
